<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[openjdk之编译经常出现的问题]]></title>
    <url>%2F2017%2F06%2F12%2Fopenjdk%E4%B9%8B%E7%BC%96%E8%AF%91%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[openjdk编译过程中，因为系统环境和openjdk版本等问题，会出现各种问题。本文主要列出两个经常出现的问题及解决办法。 time is more than 10 years from present12345Error: time is more than 10 years from present: 1136059200000Java.lang.RuntimeException: time is more than 10 years from present: 1136059200000 at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:285) at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:225) at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:154) 解决办法: 修改CurrencyData.properties（路径：jdk/src/share/classes/java/util/CurrencyData.properties） 修改108行AZ=AZM;2009-12-31-20-00-00;AZN修改381行MZ=MZM;2009-06-30-22-00-00;MZN修改443行RO=ROL;2009-06-30-21-00-00;RON修改535行TR=TRL;2009-12-31-22-00-00;TRY修改561行VE=VEB;2009-01-01-04-00-00;VEF OS is not supported: Linux … 4.0.0-1-amd64 …openjdk在编译时检查linux的内核版本，之前的检查代码没有检查4.x版本(那个时候还没有这个版本的内核)，导致出错。我们只需要在对应的检查代码里加上即可。 在文件hotspot/make/linux/Makefile中，修改如下：12-SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3%+SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3% 4%]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>openjdk</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk8之编译和debug]]></title>
    <url>%2F2017%2F06%2F12%2Fopenjdk8%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug%2F</url>
    <content type="text"><![CDATA[系统环境为ubuntu 16.04，uname -a:1Linux ddy-Aspire-V5-573G 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux 在本文中，要编译的openjdk版本为:openjdk-8u40-src-b25-10_feb_2015。尝试了编译openjdk-8-src-b132-03_mar_2014，但是失败。网上说,因为ubuntu16.04较新，但是该版本的JDK较老，所以失败。 下面说明编译和debug过程。 make版本OpenJDK8可以使用”config &amp;&amp; make”编译构建，不再使用Ant和ALT_ *环境变量来配置构建。不过需要GNU make 3.81或更新的版本 安装引导JDK我使用的引导JDK是jdk-7u76-linux-x64。123java version "1.6.0_45"Java(TM) SE Runtime Environment (build 1.6.0_45-b06)Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode) 安装编译工具类库：安装gcc、g++、make等sudo apt-get install build-essential安装XRendersudo apt-get install libxrender-devsudo apt-get install xorg-dev安装alsasudo apt-get install libasound2-devCupssudo apt-get install libcups2-dev安装零碎的工具包sudo apt-get install gawk zip libxtst-dev libxi-dev libxt-dev 建立编译脚本–with-boot-jdk：指定引导JDK所在目录，以防其他安装的JDK影响（本机上以前安装了JDK8，并配置了JAVA_HOME指向JDK8）；–with-target-bits：指定编译64位系统的JDK； 为可以进行源码调试，再指定下面三个参数：–with-debug-level=slowdebug：指定可以生成最多的调试信息；–enable-debug-symbols ZIP_DEBUGINFO_FILES=0：生成调试的符号信息，并且不压缩；在openjdk目录下新建build.sh，内容如下:123cd openjdk bash ./configure --with-target-bits=64 --with-boot-jdk=/usr/java/jdk1.7.0_80/ --with-debug-level=slowdebug --enable-debug-symbols ZIP_DEBUGINFO_FILES=0 make all ZIP_DEBUGINFO_FILES=0 编译执行./build.sh编译完成是这样的： 用GDB测试是否能debug12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ ./java -versionopenjdk version "1.8.0-internal-debug"OpenJDK Runtime Environment (build 1.8.0-internal-debug-ddy_2017_06_11_23_26-b00)OpenJDK 64-Bit Server VM (build 25.40-b25-debug, mixed mode)ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ export CLASSPATH=.:/home/ddy/java_srcddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ gdb --args java FileChannelTestGNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1Copyright (C) 2016 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law. Type "show copying"and "show warranty" for details.This GDB was configured as "x86_64-linux-gnu".Type "show configuration" for configuration details.For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;.Find the GDB manual and other documentation resources online at:&lt;http://www.gnu.org/software/gdb/documentation/&gt;.For help, type "help".Type "apropos word" to search for commands related to "word"...Reading symbols from java...done.(gdb) break init.cpp:95No source file named init.cpp.Make breakpoint pending on future shared library load? (y or [n]) yBreakpoint 1 (init.cpp:95) pending.(gdb) runStarting program: /home/ddy/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java FileChannelTest[Thread debugging using libthread_db enabled]Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".[New Thread 0x7ffff7fc8700 (LWP 9311)][Switching to Thread 0x7ffff7fc8700 (LWP 9311)]Thread 2 "java" hit Breakpoint 1, init_globals () at /home/ddy/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/hotspot/src/share/vm/runtime/init.cpp:9595 jint init_globals() &#123;(gdb) l90 chunkpool_init();91 perfMemory_init();92 &#125;93 94 95 jint init_globals() &#123;96 HandleMark hm;97 management_init();98 bytecodes_init();99 classLoader_init();(gdb) quitA debugging session is active. Inferior 1 [process 9307] will be killed.Quit anyway? (y or n) yddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ openjdk之编译经常出现的问题openjdk7的编译和debug编译主要参考：ubuntu14.04 编译openjdk7debug主要参考：CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>openjdk</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk之编译和debug]]></title>
    <url>%2F2017%2F06%2F11%2Fopenjdk7%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug%2F</url>
    <content type="text"><![CDATA[为了更好的学习JDK、HotSpot等源码，需要能debug JDK、HotSpot等源码。本文主要讲述，怎么编译openjdk并debug相关源码。在本文中，要编译的openjdk:openjdk-7u40-fcs-src-b43-26_aug_2013.zip系统环境为ubuntu 16.04，uname -a:1Linux ddy-Aspire-V5-573G 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux 编译 下载源代码 openjdk的源码可以通过hg方式下载。 也可以从此处下载：openjdk源码 安装引导JDK 因为JDK中有很多代码是Java自身实现的，所以还需要一个已经安装在本机上可用的JDK，叫做“Bootstrap JDK”。我所选用的Bootstarp JDK是JDK1.6.0_45。 123java version "1.6.0_45"Java(TM) SE Runtime Environment (build 1.6.0_45-b06)Java HotSpot(TM) Server VM (build 20.45-b01, mixed mode) JDK1.6.0_45下载地址：jdk1.6.0_45.tar.gz 安装编译前的依赖环境 安装gcc、g++、make等 sudo apt-get install build-essential 安装ant 1.7以上 sudo apt-get install ant 安装XRender sudo apt-get install libxrender-dev sudo apt-get install xorg-dev 安装alsa sudo apt-get install libasound2-dev Cups sudo apt-get install libcups2-dev 安装零碎的工具包 sudo apt-get install gawk zip libxtst-dev libxi-dev libxt-dev 配置编译脚本 将你的openjdk解压后，并进入该文件夹。比如我的是在/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk下。新建一个build.sh，并添加如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243export LANG=C#将一下两项设置为你的BootstrapJDK安装目录export ALT_BOOTDIR=/home/ddy/jdk1.6.0_45export ALT_JDK_IMPORT_PATH=/home/ddy/jdk1.6.0_45#允许自动下载依赖包export ALLOW_DOWNLOADS=true#使用预编译头文件，以提升便以速度export USE_PRECOMPILED_HEADER=true#要编译的内容，我只选择了LANGTOOLS、HOTSPOT以及JDKexport BUILD_LANGTOOLS=trueexport BUILD_JAXP=falseexport BUILD_JAXWS=falseexport BUILD_CORBA=falseexport BUILD_HOSTPOT=trueexport BUILD_JDK=true#要编译的版本export SKIP_DEBUG_BUILD=falseexport SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debug#避免javaws和浏览器Java插件等的buildBUILD_DEPLOY=false#不build安装包BUILD_INSTALL=false#包含全部的调试信息export ENABLE_FULL_DEBUG_SYMBOLS=1#调试信息是否压缩，如果配置为１,libjvm.debuginfo会被压缩成libjvm.diz,将不能被debug。export ZIP_DEBUGINFO_FILES=0#用于编译线程数export HOTSPOT_BUILD_JOBS=3#设置存放编译结果的目录#export ALT_OUTPUTDIR=/home/ddy/openjdk/7/buildunset CLASSPATHunset JAVA_HOMEmake sanityDEBUG_BINARIES=true make 2&gt;&amp;1 5.开始编译 在openjdk目录下，运行build.sh 12chmod +x build.sh./build.sh 最后编译耗时将近2分钟。编译完成输出如下信息： ![compile-success][4] 此时openjdk就编译完成了，编译的输出在``/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/``下。 进入/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2re-image/bin n，执行 ./java -version 输出的java版本信息将是带着你的机器用户名，我的输出是： 123openjdk version "1.7.0-internal-debug"OpenJDK Runtime Environment (build 1.7.0-internal-debug-ddy_2017_06_10_22_30-b00)OpenJDK 64-Bit Server VM (build 24.0-b56-jvmg, mixed mode) debug编译完成了之后，就可以对JDK源码和HotSpot源码等进行debug了。 JDK首先是JDK源码，在build目录下编译生成的jdk里面的jar包都是可编译的了，直接把eclipse的JDK或者JRE换成编译成功的JDK或者JRE即可。 HotSpot注意，如果不能进入断点，出现以下类似信息： Missing separate debuginfo for/root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/libjvm.so是因为在编译时因为编译配置项不正确而没有生成调试的符号信息，或生成后被压缩为”libjvm.diz”了，所以无法找到。如果是因为没有编译时没有生成调试信息，需要修改编译配置并重新编译。对于被压缩的情况，可以去到”libjvm.so”所在目录 然后解压：unzip libjvm.diz 解压出来：libjvm.debuginfo 如果在编译时，把配置信息修改如下，则不会出现不能上述问题。1234#包含全部的调试信息export ENABLE_FULL_DEBUG_SYMBOLS=1#调试信息是否压缩，如果配置为１,libjvm.debuginfo会被压缩成libjvm.diz,将不能被debug。export ZIP_DEBUGINFO_FILES=0 使用GDB 参考：CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码 使用eclipse 生成要运行的JAVA类 首先在/home/ddy/src/java-src目录下建立要运行的FileChannelTest.java，这个类在写文件时调用了JDK的native方法，其代码如下： 12345678910111213import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class FileChannelTest &#123; public static void main(String[] args) throws IOException &#123; FileChannel channel=new RandomAccessFile("test.txt","rw").getChannel(); ByteBuffer buffer=ByteBuffer.allocate(1000); channel.write(buffer); &#125;&#125; 然后对其进行编译,运行: 1234ddy@ddy-Aspire-V5-573G ~ $ cd src/java-src/ddy@ddy-Aspire-V5-573G ~/src/java-src $ pwd/home/ddy/src/java-srcddy@ddy-Aspire-V5-573G ~/src/java-src $ /home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image/bin/javac FileChannelTest.java 下载eclipse,安装C/C++插件 到官网选择一个合适的eclipse下载，因为本人主要进行JAVA开发，所以下载的是j2EE版本，这个版本没有C/C++的功能。不过可以安装插件使其支持C/C++功能。”help -&gt; Eclipse Maketplace”,搜索”c++”找到Eclipse C++ IDE..安装。安装后，就可以转到C++开发视图界面了。 导入hotspot工程 File-&gt; New -&gt; Makefile Project With Existing Code 在界面中: Project Name：openjdk（这个可以自己选择） Existing Code Location：/root/openjdk Toolchain：选Linux GCC，然后按Finish. 配置源码调试 右键工程 -&gt; Debug As -&gt; Debug Configurations -&gt; 右键左边的C/C++ Application -&gt; New -&gt; 进入Main选项卡；在选项卡中: **Project：** openjdk（选择导入的openjdk工程） **C/C++ Application：** ``/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image/bin/java``（编译生成的openjdk虚拟机入口） **Disable auto build：**因为不再在eclipse里面编译hotspot源码,所以这里选上它； 然后切换到Arguments选项卡, 输入Java参数, 这里填上 “FileChannelTest”也就是我们要执行的JAVA程序。 然后切换到Environment选项卡, 添加变量：JAVA_HOME=/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image（编译生成JDK所在目录）CLASSPATH=.:/home/ddy/src/java-src (FileChannelTest.java文件所在目录)点击下面的Apply保存； 断点Debug 下面分别在源码上打两个断点： init.cpp(/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/hotspot/src/share/vm/runtime目录下) 95行 FileDispatchImpl.c(/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/jdk/src/solaris/native/sun/nio/ch目录下) 107行 然后开始debug。 首先是第一个断点： F8进行到下一个断电点： 从上图可以看到,FileChannel.write()最后调用的是write()操作系统调用。 所以，大家现在可以随便debug HotSpot的源码和JDK的native源码了。酷！ 参考资料openjdk之编译经常出现的问题openjdk8的编译和debug编译主要参考：ubuntu14.04 编译openjdk7debug主要参考：CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>openjdk</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer]]></title>
    <url>%2F2017%2F06%2F08%2FBuffer%2F</url>
    <content type="text"><![CDATA[本机环境：Linux 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux Buffer Buffer的类图如下： 除了Boolean，其他基本数据类型都有对应的Buffer，但是只有ByteBuffer才能和Channel交互。只有ByteBuffer才能产生Direct的buffer，其他数据类型的Buffer只能产生Heap类型的Buffer。ByteBuffer可以产生其他数据类型的视图Buffer，如果ByteBuffer本身是Direct的，则产生的各视图Buffer也是Direct的。 Direct和Heap类型Buffer的本质首选说说JVM是怎么进行IO操作的。 JVM在需要通过操作系统调用完成IO操作，比如可以通过read系统调用完成文件的读取。read的原型是：ssize_t read(int fd,void *buf,size_t nbytes)，和其他的IO系统调用类似，一般需要缓冲区作为其中一个参数，该缓冲区要求是连续的。 Buffer分为Direct和Heap两类，下面分别说明这两类buffer。 HeapHeap类型的Buffer存在于JVM的堆上，这部分内存的回收与整理和普通的对象一样。Heap类型的Buffer对象都包含一个对应基本数据类型的数组属性（比如：final **[] hb），数组才是Heap类型Buffer的底层缓冲区。但是Heap类型的Buffer不能作为缓冲区参数直接进行系统调用，主要因为下面两个原因。 JVM在GC时可能会移动缓冲区（复制-整理），缓冲区的地址不固定。 系统调用时，缓冲区需要是连续的，但是数组可能不是连续的（JVM的实现没要求连续）。 所以使用Heap类型的Buffer进行IO时，JVM需要产生一个临时Direct类型的Buffer，然后进行数据复制，再使用临时Direct的Buffer作为参数进行操作系统调用。这造成很低的效率，主要是因为两个原因： 需要把数据从Heap类型的Buffer里面复制到临时创建的Direct的Buffer里面。 可能产生大量的Buffer对象，从而提高GC的频率。所以在IO操作时，可以通过重复利用Buffer进行优化。 DirectDirect类型的buffer，不存在于堆上，而是JVM通过malloc直接分配的一段连续的内存，这部分内存成为直接内存，JVM进行IO系统调用时使用的是直接内存作为缓冲区。-XX:MaxDirectMemorySize，通过这个配置可以设置允许分配的最大直接内存的大小（MappedByteBuffer分配的内存不受此配置影响）。直接内存的回收和堆内存的回收不同，如果直接内存使用不当，很容易造成OutOfMemoryError。JAVA没有提供显示的方法去主动释放直接内存，sun.misc.Unsafe类可以进行直接的底层内存操作，通过该类可以主动释放和管理直接内存。同理，也应该重复利用直接内存以提高效率。 MappedByteBuffer和DirectByteBuffer之间的关系 This is a little bit backwards: By rights MappedByteBuffer should be a subclass of DirectByteBuffer, but to keep the spec clear and simple, and for optimization purposes, it’s easier to do it the other way around.This works because DirectByteBuffer is a package-private class.（本段话摘自MappedByteBuffer的源码） 实际上，MappedByteBuffer属于映射buffer（自己看看虚拟内存），但是DirectByteBuffer只是说明该部分内存是JVＭ在直接内存区分配的连续缓冲区，并不一是映射的。也就是说MappedByteBuffer应该是DirectByteBuffer的子类，但是为了方便和优化，把MappedByteBuffer作为了DirectByteBuffer的父类。另外，虽然MappedByteBuffer在逻辑上应该是DirectByteBuffer的子类，而且MappedByteBuffer的内存的GC和直接内存的GC类似（和堆GC不同），但是分配的MappedByteBuffer的大小不受-XX:MaxDirectMemorySize参数影响。MappedByteBuffer封装的是内存映射文件操作，也就是只能进行文件IO操作。MappedByteBuffer是根据mmap产生的映射缓冲区，这部分缓冲区被映射到对应的文件页上，属于直接内存在用户态，通过MappedByteBuffer可以直接操作映射缓冲区，而这部分缓冲区又被映射到文件页上，操作系统通过对应内存页的调入和调出完成文件的写入和写出。 MappedByteBuffer 通过FileChannel.map(MapMode mode,long position, long size)得到MappedByteBuffer，下面结合源码说明MappedByteBuffer的产生过程。 FileChannel.map的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public MappedByteBuffer map(MapMode mode, long position, long size) throws IOException &#123; ensureOpen(); if (position &lt; 0L) throw new IllegalArgumentException("Negative position"); if (size &lt; 0L) throw new IllegalArgumentException("Negative size"); if (position + size &lt; 0) throw new IllegalArgumentException("Position + size overflow"); //最大2G if (size &gt; Integer.MAX_VALUE) throw new IllegalArgumentException("Size exceeds Integer.MAX_VALUE"); int imode = -1; if (mode == MapMode.READ_ONLY) imode = MAP_RO; else if (mode == MapMode.READ_WRITE) imode = MAP_RW; else if (mode == MapMode.PRIVATE) imode = MAP_PV; assert (imode &gt;= 0); if ((mode != MapMode.READ_ONLY) &amp;&amp; !writable) throw new NonWritableChannelException(); if (!readable) throw new NonReadableChannelException(); long addr = -1; int ti = -1; try &#123; begin(); ti = threads.add(); if (!isOpen()) return null; //size()返回实际的文件大小 //如果实际文件大小不符合，则增大文件的大小，文件的大小被改变，文件增大的部分默认设置为0。 if (size() &lt; position + size) &#123; // Extend file size if (!writable) &#123; throw new IOException("Channel not open for writing " + "- cannot extend file to required size"); &#125; int rv; do &#123; //增大文件的大小 rv = nd.truncate(fd, position + size); &#125; while ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen()); &#125; //如果要求映射的文件大小为0，则不调用操作系统的mmap调用，只是生成一个空间容量为0的DirectByteBuffer //并返回 if (size == 0) &#123; addr = 0; // a valid file descriptor is not required FileDescriptor dummy = new FileDescriptor(); if ((!writable) || (imode == MAP_RO)) return Util.newMappedByteBufferR(0, 0, dummy, null); else return Util.newMappedByteBuffer(0, 0, dummy, null); &#125; //allocationGranularity的大小在我的系统上是4K //页对齐，pagePosition为第多少页 int pagePosition = (int)(position % allocationGranularity); //从页的最开始映射 long mapPosition = position - pagePosition; //因为从页的最开始映射，增大映射空间 long mapSize = size + pagePosition; try &#123; // If no exception was thrown from map0, the address is valid //native方法，源代码在openjdk/jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c, //参见下面的说明 addr = map0(imode, mapPosition, mapSize); &#125; catch (OutOfMemoryError x) &#123; // An OutOfMemoryError may indicate that we've exhausted memory // so force gc and re-attempt map System.gc(); try &#123; Thread.sleep(100); &#125; catch (InterruptedException y) &#123; Thread.currentThread().interrupt(); &#125; try &#123; addr = map0(imode, mapPosition, mapSize); &#125; catch (OutOfMemoryError y) &#123; // After a second OOME, fail throw new IOException("Map failed", y); &#125; &#125; // On Windows, and potentially other platforms, we need an open // file descriptor for some mapping operations. FileDescriptor mfd; try &#123; mfd = nd.duplicateForMapping(fd); &#125; catch (IOException ioe) &#123; unmap0(addr, mapSize); throw ioe; &#125; assert (IOStatus.checkAll(addr)); assert (addr % allocationGranularity == 0); int isize = (int)size; Unmapper um = new Unmapper(addr, mapSize, isize, mfd); if ((!writable) || (imode == MAP_RO)) &#123; return Util.newMappedByteBufferR(isize, addr + pagePosition, mfd, um); &#125; else &#123; return Util.newMappedByteBuffer(isize, addr + pagePosition, mfd, um); &#125; &#125; finally &#123; threads.remove(ti); end(IOStatus.checkAll(addr)); &#125; &#125; map0的源码实现：1234567891011121314151617181920212223242526272829303132333435363738394041JNIEXPORT jlong JNICALLJava_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jint prot, jlong off, jlong len)&#123; void *mapAddress = 0; jobject fdo = (*env)-&gt;GetObjectField(env, this, chan_fd); //linux系统调用是通过整型的文件id引用文件的，这里得到文件id jint fd = fdval(env, fdo); int protections = 0; int flags = 0; if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123; protections = PROT_READ; flags = MAP_SHARED; &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123; protections = PROT_WRITE | PROT_READ; flags = MAP_SHARED; &#125; else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123; protections = PROT_WRITE | PROT_READ; flags = MAP_PRIVATE; &#125; //这里就是操作系统调用了，mmap64是宏定义，实际最后调用的是mmap mapAddress = mmap64( 0, /* Let OS decide location */ len, /* Number of bytes to map */ protections, /* File permissions */ flags, /* Changes are shared */ fd, /* File descriptor of mapped file */ off); /* Offset into file */ if (mapAddress == MAP_FAILED) &#123; if (errno == ENOMEM) &#123; //如果没有映射成功，直接抛出OutOfMemoryError JNU_ThrowOutOfMemoryError(env, "Map failed"); return IOS_THROWN; &#125; return handle(env, -1, "Map failed"); &#125; return ((jlong) (unsigned long) mapAddress);&#125; 虽然FileChannel.map()的zise参数是long，但是size的大小最大为Integer.MAX_VALUE,也就是最大只能映射最大2G大小的空间。实际上操作系统提供的MMAP可以分配更大的空间，但是JAVA限制在2G，ByteBuffer等Buffer也最大只能分配2G大小的缓冲区。MappedByteBuffer是通过mmap产生得到的缓冲区，这部分缓冲区是由操作系统直接创建和管理的，最后JVM通过unmmap让操作系统直接释放这部分内存。 Haep**Buffer下面以ByteBuffer为例，说明Heap类型Buffer的细节。该类型的Buffer可以通过下面方式产生： ByteBuffer.allocate(int capacity) ByteBuffer.wrap(byte[] array)使用传入的数组作为底层缓冲区，变更数组会影响缓冲区，变更缓冲区也会影响数组。 ByteBuffer.wrap(byte[] array,int offset, int length)使用传入的数组的一部分作为底层缓冲区，变更数组的对应部分会影响缓冲区，变更缓冲区也会影响数组。 DirectByteBuffer DirectByteBuffer只能通过ByteBuffer.allocateDirect(int capacity) 产生。 ByteBuffer.allocateDirect()源码如下： 123 public static ByteBuffer allocateDirect(int capacity) &#123; return new DirectByteBuffer(capacity);&#125; DirectByteBuffer()源码如下： 123456789101112131415161718192021222324252627282930313233DirectByteBuffer(int cap) &#123; // package-private super(-1, 0, cap, cap); //直接内存是否要页对齐，我本机测试的不用 boolean pa = VM.isDirectMemoryPageAligned(); //页的大小，本机测试的是4K int ps = Bits.pageSize(); //如果页对齐，则size的大小是ps+cap，ps是一页，cap也是从新的一页开始，也就是页对齐了 long size = Math.max(1L, (long)cap + (pa ? ps : 0)); //JVM维护所有直接内存的大小，如果已分配的直接内存加上本次要分配的大小超过允许分配的直接内存的最大值会 //引起GC，否则允许分配并把已分配的直接内存总量加上本次分配的大小。如果GC之后，还是超过所允许的最大值， //则throw new OutOfMemoryError(&quot;Direct buffer memory&quot;); Bits.reserveMemory(size, cap); long base = 0; try &#123; //是吧，unsafe可以直接操作底层内存 base = unsafe.allocateMemory(size); &#125; catch (OutOfMemoryError x) &#123;、 //没有分配成功，把刚刚加上的已分配的直接内存的大小减去。 Bits.unreserveMemory(size, cap); throw x; &#125; unsafe.setMemory(base, size, (byte) 0); if (pa &amp;&amp; (base % ps != 0)) &#123; // Round up to page boundary address = base + ps - (base &amp; (ps - 1)); &#125; else &#123; address = base; &#125; cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); att = null;&#125; unsafe.allocateMemory()的源码在openjdk/src/openjdk/hotspot/src/share/vm/prims/unsafe.cpp中。具体的源码如下：123456789101112131415161718UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size)) UnsafeWrapper("Unsafe_AllocateMemory"); size_t sz = (size_t)size; if (sz != (julong)size || size &lt; 0) &#123; THROW_0(vmSymbols::java_lang_IllegalArgumentException()); &#125; if (sz == 0) &#123; return 0; &#125; sz = round_to(sz, HeapWordSize); //最后调用的是 u_char* ptr = (u_char*)::malloc(size + space_before + space_after)，也就是malloc。 void* x = os::malloc(sz, mtInternal); if (x == NULL) &#123; THROW_0(vmSymbols::java_lang_OutOfMemoryError()); &#125; //Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize); return addr_to_java(x);UNSAFE_END JVM通过malloc分配得到连续的缓冲区，这部分缓冲区可以直接作为缓冲区参数进行操作系统调用。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Buffer</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码之编译]]></title>
    <url>%2F2017%2F06%2F05%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[本文主要说明如何编译组成rt.jar的源码，不涉及JVM的编译。 rt.jarrt.jar也就是运行时相关的class类，安装的jre里面的rt.jar是不能被debug的，为了对JDK的源码进行debug跟踪，需要重新编译rt.jar。rt.jar的全部源码在openjdk的jdk目录下，具体的路径是openjdk\jdk\src\，源码根据操作系统的不同和是否共享分成几个目录。实际上rt.jar因为操作系统的不同，所包含的class也会有所不同，这导致在一些特殊特性上JAVA不再是“一次编译，到处执行”。比如，在java7中，linux/unix下的jre支持com.sun.java.swing.plaf.gtk.GTKLookAndFeel,但是windows就不支持。操作系统安装的JDK里面的src.zip不包含sun.*包，sun.\包在openjdk源码里面,具体的路径是：jdk\src\share\classes。src.zip除了缺少sun.*包，还缺少其他源代码，不过这些源代码都能在share目录和各操作系统对应目录下找到。openjdk的目录说明和源码下载参见：openjdk目录 编译本文编译的是openjdk-7里面jdk目录下的源码。 新建java project 将openjdk源码copy到project中。除了复制share目录下的共享源码，还需要复制具体操作系统下的源码。 编译导出jar。 参考资料：怎么对jdk核心包进行跟踪调试，并查看调试中的变量值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk源码目录]]></title>
    <url>%2F2017%2F06%2F05%2Fopenjdk%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文主要参考自：openjdk源码结构 源码下载openjdk-7的源码：openjdk7源码openjdk-8的源码：openJDK8源码 目录说明openjdk的源码的目录结构如下图所示： 各个目录的说明如下：—— corba：不流行的多语言、分布式通讯接口—— hotspot：Java 虚拟机—— jaxp：XML 处理—— jaxws：一组 XML web services 的 Java API—— jdk：java 开发工具包—— —— 针对操作系统的部分—— —— share：与平台无关的实现—— langtools：Java 语言工具—— nashorn：JVM 上的 JavaScript 运行时 为了让大家易于理解，有所简化了结构。 Corba全称 Common Object Request Broker Architecture，通用对象请求代理架构，是基于 对象-服务 机制设计得。 与 JavaBean、COM 等是同种范畴。 目前，通用的远程过程调用协议是 SOAP（Simple Object Access Protocol，简单对象访问协议），消息格式是 XML-RPC（存在 Json-RPC）。另外，Apache Thrift 提供了多语言 C/S 通讯支持； 不少语言也内置了跨语言调用或对分布式环境友好，比如： lua 可以与 c 代码互调用，Go 可以调用 C 代码，erlang 在本地操作与分布式环境下的操作方法一样等。Corba和RMI类似，都能实现RPC。但是RMI只是针对JAVA环境的，Corba是支持多语言的方案 Hotspot全称 Java HotSpot Performance Engine，是 Java 虚拟机的一个实现，包含了服务器版和桌面应用程序版。利用 JIT 及自适应优化技术（自动查找性能热点并进行动态优化）来提高性能。 使用 java -version 可以查看 Hotspot 的版本。 从 Java 1.3 起为默认虚拟机，现由 Oracle 维护并发布。 其他 java 虚拟机： JRockit：专注于服务器端，曾经号称是“世界上速度最快的 Java 虚拟机”，现归于 Oracle 旗下。 J9：IBM 设计的 Java 虚拟机。 Harmony：Apache 的顶级项目之一，从 2011 年 11 月 6 日起入驻 Apache 的 Java 项目。虽然其能够兼容 jdk，但由于 JCP （Java Community Process）仅仅允许授权给 Harmony 一个带有限制条件的TCK（Technology Compatibility Kit），即仅仅能使用在 J2SE ,而不是所有Java实现上（包括 J2ME 和 J2EE），导致了 Apache 组织与 Oracle 的决裂。Harmony 是 Android 虚拟机 Dalvik 的前身。 Dalvik 并不是 Java 虚拟机，它执行的是 dex 文件而不是 class 文件，使用的也是寄存器架构而不是栈架构 。 jaxp全称 Java API for XML Processing，处理 XML 的Java API，是 Java XML 程序设计的应用程序接口之一，它提供解析和验证XML文档的能力。jaxp 提供了处理 xml 文件的三种接口： DOM 接口（文档对象模型解析），位于 \openjdk\jaxp\src\org\w3c\dom SAX 接口（xml 简单 api 解析），位于 \openjdk\jaxp\src\org\xml\sax StAX 接口（xml 流 api），位于 \openjdk\jaxp\src\javax\xml 除了解析接口，JAXP还提供了XSLT接口用来对XML文档进行数据和结构的转换。 JaxWS全称 Java API for Web Services，JAX-WS 允许开发者选择 RPC-oriented（面向 RPC） 或者 message-oriented（消息通信，erlang 使用的就是消息通信，不过 Java 内存模型是内存共享）来实现自己的web services。 通过 Web Services 提供的环境，可以实现 Java 与其他编程语言的交互（事实上就是 thrift 所做的，任何一种语言都可以通过 Web Services 实现与其他语言的通信，客户端用一种语言，服务器端可以用其他语言）。 LangToolsJava 语言支持工具 JDK全称 Java Development Kit。 share classes 目录里的是 Java 的实现，native 目录里的是 C++ 的实现，两部分基本对应。这两个目录里的结构与 java 的包也是对应，各个部分的用途另外再讲。 back、instrument、javavm、npt、transport 几个部分是实现 java 的基础部分，都是 C++ 代码，在这里从最底层理解 java，往后这些内容也会详讲。 sample 和 demo 目录有以下示例，区别在于 demo 目录是 针对 applets 的。 NashornNashorn 项目的目的是基于 Java 在 JVM 上实现一个轻量级高性能的 JavaScript 运行环境。基于 JSR-223 协议，Java 程序员可在 Java 程序中嵌入 JavaScript 代码。该项目使用了 JSR-229 里描述的新连接机制（从 Java7起开始使用的连接机制）：新的字节码（invokedynamic）以及新的基于方法句柄（method handle）的连接机制。通过接口注入（interface injection）在运行时修改类也是 JSR-229 里的内容。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA IO]]></title>
    <url>%2F2017%2F06%2F04%2FJAVA-IO%2F</url>
    <content type="text"><![CDATA[计算机IO本部分内容主要参考自《JAVA NIO》的第一章简介。 缓冲区操作下图简单描述了数据从外部磁盘向运行中的进程的内存区域移动的过程。进程使用 read( )系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主 CPU 协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行 read()调用时指定的缓冲区。 为什么不让磁盘控制器直接将磁盘上数据直接copy到用户缓冲区呢？ 硬件无法直接访问用户空间 像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。 发散和汇聚根据发散／汇聚的概念，进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来（如下图所示）。优点： 这样用户进程就不必多次执行系统调用（那样做可能代价不菲） 内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。 如果系统配有多个 CPU，甚至可以同时填充或排干多个缓冲区。 多个缓冲区可能方便一些特定协议的编程（自己加的）。 虚拟内存现代操作系统都支持虚拟内存，CPU为了更好的支持虚拟内存也加入了MMU（内存管理单元）。在寻址时，需要把虚拟地址经过MMU计算得到真实的物理地址，然后再去寻址。虚拟内存的好处： 一个以上的虚拟地址可指向同一个物理内存地址。 虚拟内存空间可大于实际可用的硬件内存。 内存页面调度为了支持虚拟内存，需要把内存存储到硬盘上，现代操作系统是通过内存页面调度实现的。对于采用分页技术的现代操作系统而言，这也是数据在磁盘与物理内存之间往来的唯一方式。下面的步骤说明了内存页面调度的过程： 当 CPU 引用某内存地址时，MMU负责确定该地址所在页（往往通过对地址值进行移位或屏蔽位操作实现），并将虚拟页号转换为物理页号（这一步由硬件完成，速度极快）。如果当前不存在与该虚拟页形成有效映射的物理内存页，MMU 会向 CPU 提交一个页错误。 页错误随即产生一个陷阱（类似于系统调用），把控制权移交给内核，附带导致错误的虚拟地址信息，然后内核采取步骤验证页的有效性。内核会安排页面调入操作，把缺失的页内容读回物理内存。这往往导致别的页被移出物理内存，好给新来的页让地方。在这种情况下，如果待移出的页已经被碰过了（自创建或上次页面调入以来，内容已发生改变），还必须首先执行页面调出，把页内容拷贝到磁盘上的分页区。 如果所要求的地址不是有效的虚拟内存地址（不属于正在执行的进程的任何一个内存段），则该页不能通过验证，段错误随即产生。于是，控制权转交给内核的另一部分，通常导致的结果就是进程被强令关闭。一旦出错的页通过了验证，MMU 随即更新，建立新的虚拟到物理的映射（如有必要，中断被移出页的映射），用户进程得以继续。造成页错误的用户进程对此不会有丝毫察觉，一切都在不知不觉中进行。 文件IO虚拟内存通过页面调度可以调度内存页和硬盘页，现代操作系统对文件IO的操作也是基于页面调度实现的。采用分页技术的操作系统执行 I/O 的全过程可总结为以下几步： 确定请求的数据分布在文件系统的哪些页（磁盘扇区组）。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。 在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。 在内存页与磁盘上的文件系统页之间建立映射。 为每一个内存页产生页错误。 虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。 一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。 内存映射文件为了在内核空间的文件系统页与用户空间的内存区之间移动数据，一次以上的拷贝操作几乎总是免不了的。这是因为，在文件系统页与用户缓冲区之间往往没有一一对应关系。但是，还有一种大多数操作系统都支持的特殊类型的 I/O 操作，允许用户进程最大限度地利用面向页的系统 I/O 特性，并完全摒弃缓冲区拷贝。这就是内存映射 I/O。内存映射文件将内存页全部映射到文件的硬盘块上，存在一一映射关系。使用内存映射文件时，用户态是没有缓冲区的，只存在映射到硬盘页的内存页面缓冲区，所以是真正的ZeroCopy。而不使用内存映射文件的IO，因为直接内存和内存页缓冲区没有映射关系，所以使使用直接内存作为缓冲区也是需要最少一次copy的。（那文件IO时使用直接内存的好处是什么？） 文件锁定JVM实现的是进程之间的锁定，一个进程之间的多个线程之间是不锁定的。支持共享锁、独占锁等支持锁定文件的部分区域，粒度支持到字节。 流IO流的传输一般（也不必然如此）比块设备慢，经常用于间歇性输入。多数操作系统允许把流置于非块模式，这样，进程可以查看流上是否有输入，即便当时没有也不影响它干别的。这样一种能力使得进程可以在有输入的时候进行处理，输入流闲置的时候执行其他功能。处理流IO需要依赖操作系统的通知机制： Selector通知已就绪，可以进行相关IO操作。 AIO通知IO操作已完成，可以处理相关业务逻辑了。 JAVA IO 发展和总结BIO 抽象工作良好，适应用途广泛。但是当移动大量数据时，这些 I/O 类可伸缩性不强，也没有提供当今大多数操作系统普遍具备的常用 I/O 功能，如文件锁定、非块 I/O、就绪性选择和内存映射。这些特性对实现可伸缩性是至关重要的，对保持与非 Java 应用程序的正常交互也可以说是必不可少的，尤其是在企业应用层面，而传统的 Java I/O 机制却没有模拟这些通用 I/O 服务。操作系统与 Java 基于流的 I/O模型有些不匹配。操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（DMA）的协助下完成的。BIO 类喜欢操作小块数据——单个字节、几行文本。 BIOJDK版本：1.1时间：特点： 同步阻塞 面向流（字节流和字符流） 不支持操作系统支持的很多IO概念和特性 read()操作返回所读的字节数，write操作没有返回值 read是SeekAble的（支持skip），write不是Seekable的。 NIO.1JDK版本：1.4时间：2002特点： 针对现代操作系统重新抽象和封装实现了Channel和Buffer 网络IO支持配置是否阻塞，文件IO只能是阻塞的 网络IO支持多路复用（异步），使用多路复用时，Channel必须是非阻塞模式，而且阻塞模式不能再被修改 网络IO和文件IO都是可中断的。文件IO过程中被中断时，JVM会关闭Channel。 支持直接Buffer、支持内存映射文件 支持文件锁定，但是是进程级别的锁定 支持Pipe read操作返回所读的字节数，write操作返回所写的字节数 Channel是全双工的。虽然RandomAccessFile也可以是全双工的，但是Channel这种封装方式更好 NIO.2（AIO）JDK版本：1.7时间：2011特点： 文件IO和网络IO是异步的（当然是非阻塞的），异步形式是future和callback。 Watch Service 文件IO支持更丰富的API BIONIO.1NIO.2异步Watch ServiceIO更丰富的文件操作]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pro Java 7 NIO 2读书笔记]]></title>
    <url>%2F2017%2F06%2F04%2FPro-Java-7-NIO-2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转自 花了几天把这本书初略的看了一下， 之所以初略的看了一下，是因为这书里确实没啥内容。如果去了NIO 1的内容和大段大段的代码， 基本上压缩到50页应该没问题。 下面简单的罗列一下看到的内容： Path这个类在java.nio.file，在NIO里对文件系统进行了进一步的抽象。 是用来替换原来的java.io.File。其中 FileSystems, Files, Path, PathMatcher 成为一个体系。 在java7里File和Path可以相互转换： File.toPath(), Path.toFile()原来的File里包含了文件引用和文件，在Path系统里， Path里是文件的引用，而文件操作都放到了Files的静态方法里。这种方式究竟好不好用，我没啥感觉。不过我个人偏向于把操作放到另外一个类里面。 获得Path实例的方式：File.toPath(), Paths.get(), FileSystem.getPath() 注意： Path和File一样，能创建出实例不代表着这个文件一定在文件系统里真是存在。 Path和File相比使用上方便了的地方： 不用特意指定路径的separator：Paths.get(&quot;C:&quot;,&quot;folder1&quot;,&quot;subfolder&quot;,&quot;aa.txt&quot;) 在windows系统了是C:\folder1\subfolder\aa.txt在Mac下是C:/folder/subfolder/aa.txtJava会根据当前操作系统来决定separator 重复利用基本路径：12345678910//define the fixed pathPath base = Paths.get("C:/rafaelnadal/tournaments/2009");//resolve BNP.txt filePath path_1 = base.resolve("BNP.txt");//output: C:\rafaelnadal\tournaments\2009\BNP.txtSystem.out.println(path_1.toString());//resolve AEGON.txt filePath path_2 = base.resolve("AEGON.txt");//output: C:\rafaelnadal\tournaments\2009\AEGON.txtSystem.out.println(path_2.toString()); 而resolveSibling方法更加好用：可以直接获取相同目录下的其他文件：123456//define the fixed pathPath base = Paths.get("C:/rafaelnadal/tournaments/2009/BNP.txt");//resolve sibling AEGON.txt filePath path = base.resolveSibling("AEGON.txt");//output: C:\rafaelnadal\tournaments\2009\AEGON.txtSystem.out.println(path.toString()); 取得相对路径：假设BNP.txt和AEGON.txt在同一目录下123456789Path path01 = Paths.get("BNP.txt");Path path02 = Paths.get("AEGON.txt");//output: ..\AEGON.txtPath path01_to_path02 = path01.relativize(path02);System.out.println(path01_to_path02);//output: ..\BNP.txtPath path02_to_path01 = path02.relativize(path01);System.out.println(path02_to_path01); 假设：12Path path01 = Paths.get("/tournaments/2009/BNP.txt");Path path02 = Paths.get("/tournaments/2011"); 那么：123456//output: ..\..\2011Path path01_to_path02 = path01.relativize(path02);System.out.println(path01_to_path02);//output: ..\2009\BNP.txtPath path02_to_path01 = path02.relativize(path01);System.out.println(path02_to_path01); 遍历：Path实现了Iterable接口，也就是说我们可以这样：1234Path path = Paths.get("C:", "rafaelnadal/tournaments/2009", "BNP.txt");for (Path name : path) &#123; System.out.println(name);&#125; 猜猜结果是什么？我一开始以为是吧目录下的文件遍历出来呢。结果是这样的：rafaelnadaltournaments2009BNP.txt说实话，我觉得这个比较坑爹！ 文件属性java.nio.file.attribute包下的类提供了获取文件属性的类，针对不同操作系统使用的类不太一样，当然也有所有操作系统通用的属性。 属性分类有一些几种：BasicFileAttributeViewDosFileAttributeViewPosixFileAttributeViewFileOwnerAttributeViewAclFileAttributeViewUserDefinedFileAttributeView 获取属性：123456789101112131415BasicFileAttributes attr = null;Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "BNP.txt");try &#123; attr = Files.readAttributes(path, BasicFileAttributes.class);&#125; catch (IOException e) &#123; System.err.println(e);&#125;System.out.println("File size: " + attr.size());System.out.println("File creation time: " + attr.creationTime());System.out.println("File was last accessed at: " + attr.lastAccessTime());System.out.println("File was last modified at: " + attr.lastModifiedTime());System.out.println("Is directory? " + attr.isDirectory());System.out.println("Is regular file? " + attr.isRegularFile());System.out.println("Is symbolic link? " + attr.isSymbolicLink());System.out.println("Is other? " + attr.isOther()); 或 long size = (Long)Files.getAttribute(path, &quot;basic:size&quot;, NOFOLLOW_LINKS); 设置属性：123456789Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "BNP.txt");long time = System.currentTimeMillis();FileTime fileTime = FileTime.fromMillis(time);try &#123; Files.getFileAttributeView(path, BasicFileAttributeView.class).setTimes(fileTime, fileTime, fileTime);&#125; catch (IOException e) &#123; System.err.println(e);&#125; 或1234567long time = System.currentTimeMillis();FileTime fileTime = FileTime.fromMillis(time);try &#123; Files.setLastModifiedTime(path, fileTime);&#125; catch (IOException e) &#123; System.err.println(e);&#125; Symbolic和Hard Links相同于用Java程序实现linux下的 ln命令。123Path link = FileSystems.getDefault().getPath("rafael.nadal.1");Path target= FileSystems.getDefault().getPath("C:/rafaelnadal/photos", "rafa_winner.jpg");Files.createSymbolicLink(link, target); DirectoryStream这也是一个比较有用的类：用来遍历路径下的子路径或文件，而且支持通配符过滤。1234567891011Path path = Paths.get("C:/rafaelnadal/tournaments/2009");…//glob pattern appliedSystem.out.println("\nGlob pattern applied:");try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path, "*.&#123;png,jpg,bmp&#125;")) &#123; for (Path file : ds) &#123; System.out.println(file.getFileName()); &#125;&#125; catch (IOException e) &#123; System.err.println(e);&#125; FileVisitor和Files.walkFileTreeFileVisitor是一个接口，Files.walkFileTree是一个方法。 通过两者的配合可以遍历整个某个路径下的所有子路径和文件。没有这个之前我们用递归方法也能实现，有了这个不能说是现实更加容易， 只能说是现实更加规范， 如果大家都用这个，代码的可维护性会更好。我觉得仅此而已。 FileVisitor有四个方法 FileVisitResult postVisitDirectory(T dir, IOException exc)Invoked for a directory after entries in the directory, and all of their descendants, have been visited. FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) Invoked for a directory before entries in the directory are visited.+FileVisitResult visitFile(T file, BasicFileAttributes attrs) Invoked for a file in a directory. FileVisitResult visitFileFailed(T file, IOException exc) Invoked for a file that could not be visited. FileVisitResult枚举类型：CONTINUE，SKIP_SIBLINGS，SKIP_SUBTREE，TERMINATE Watch Service API这是NIO2里比较重要的一个新增功能， 以前直接用java监视文件系统的变化是不可能的，只能通过jni的方式调用操作系统的api来对文件系统进行监视。在java7里这部分被加到了标准库里，这样我们就不能在去寻找jni的结果方案了。但是事实上为了保持java的扩平台特性，监控的功能范围被定为各个操作系统的交集，所以没有特殊的情况还是需要直接调用操作系统的api来实现。1234567891011121314151617181920212223242526272829303132public void watchRNDir(Path path) throws IOException, InterruptedException &#123; try (WatchService watchService = FileSystems.getDefault().newWatchService()) &#123; path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE); //start an infinite loop while (true) &#123; //retrieve and remove the next watch key final WatchKey key = watchService.take(); //get list of pending events for the watch key for (WatchEvent&lt;?&gt; watchEvent : key.pollEvents()) &#123; //get the kind of event (create, modify, delete) final Kind&lt;?&gt; kind = watchEvent.kind(); //handle OVERFLOW event if (kind == StandardWatchEventKinds.OVERFLOW) &#123; continue; &#125; //get the filename for the event final WatchEvent&lt;Path&gt; watchEventPath = (WatchEvent&lt;Path&gt;) watchEvent; final Path filename = watchEventPath.context(); //print it out System.out.println(kind + " -&gt; " + filename); &#125; //reset the key boolean valid = key.reset(); //exit loop if the key is not valid (if the directory was deleted, for example) if (!valid) &#123; break; &#125; &#125; &#125;&#125; Random Access Files主要是提供了一个SeekableByteChannel接口，配合ByteBuffer使随机访问文件更加方便。12345678910111213141516171819202122232425262728Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "MovistarOpen.txt");ByteBuffer buffer = ByteBuffer.allocate(1);String encoding = System.getProperty("file.encoding");try (SeekableByteChannel seekableByteChannel = (Files.newByteChannel(path, EnumSet.of(StandardOpenOption.READ)))) &#123; //the initial position should be 0 anyway seekableByteChannel.position(0); System.out.println("Reading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.rewind(); //get into the middle seekableByteChannel.position(seekableByteChannel.size()/2); System.out.println("\nReading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.rewind(); //get to the end seekableByteChannel.position(seekableByteChannel.size()-1); System.out.println("\nReading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.clear();&#125; catch (IOException ex) &#123; System.err.println(ex);&#125; Asynchronous Channel API这个是NIO2的较大的变化，有原来的Selecor方法变成方法回调模式。使用上更加方便。并且文件的读写也可以异步的方式实现了。 异步读取文件 ：12345678910111213141516171819202122232425262728ByteBuffer buffer = ByteBuffer.allocate(100);Path path = Paths.get("C:/rafaelnadal/grandslam/RolandGarros", "story.txt");try (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123; current = Thread.currentThread(); asynchronousFileChannel.read(buffer, 0, "Read operation status ...", new CompletionHandler&lt;Integer, Object&gt;() &#123; @Override public void completed(Integer result, Object attachment) &#123; System.out.println(attachment); System.out.print("Read bytes: " + result); current.interrupt(); &#125; @Override public void failed(Throwable exc, Object attachment) &#123; System.out.println(attachment); System.out.println("Error:" + exc); current.interrupt(); &#125; &#125;); System.out.println("\nWaiting for reading operation to end ...\n"); try &#123; current.join(); &#125; catch (InterruptedException e) &#123; &#125; //now the buffer contains the read bytes System.out.println("\n\nClose everything and leave! Bye, bye ...");&#125; catch (Exception ex) &#123; System.err.println(ex);&#125; 异步socket服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class AsyncEchoServer &#123; private AsynchronousServerSocketChannel serverChannel; public void start() throws IOException &#123; System.out.println(String.format("start: name: %s", Thread.currentThread().getName())); serverChannel = AsynchronousServerSocketChannel.open(); serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); serverChannel.bind(new InetSocketAddress(8000)); serverChannel.accept(serverChannel, new Acceptor()); &#125; class Acceptor implements CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt; &#123; private final ByteBuffer buffer = ByteBuffer.allocate(1024); public Acceptor()&#123; System.out.println("an acceptor has created."); &#125; public void completed(final AsynchronousSocketChannel channel, AsynchronousServerSocketChannel serverChannel) &#123; System.out.println(String.format("write: name: %s", Thread.currentThread().getName())); channel.read(buffer, channel, new Reader(buffer)); serverChannel.accept(serverChannel, new Acceptor()); &#125; public void failed(Throwable exception, AsynchronousServerSocketChannel serverChannel) &#123; throw new RuntimeException(exception); &#125; &#125; class Reader implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; &#123; private ByteBuffer buffer; public Reader(ByteBuffer buffer)&#123; this.buffer = buffer; &#125; public void completed(Integer result, AsynchronousSocketChannel channel)&#123; System.out.println(String.format("read: name: %s", Thread.currentThread().getName())); if(result != null &amp;&amp; result &lt; 0)&#123; try&#123; channel.close(); return; &#125;catch(IOException ignore)&#123;&#125; &#125; buffer.flip(); channel.write(buffer, channel, new Writer(buffer)); &#125; public void failed(Throwable exception, AsynchronousSocketChannel channel)&#123; throw new RuntimeException(exception); &#125; &#125; class Writer implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; &#123; private ByteBuffer buffer; public Writer(ByteBuffer buffer)&#123; this.buffer = buffer; &#125; public void completed(Integer result, AsynchronousSocketChannel channel) &#123; System.out.println(String.format("write: name: %s", Thread.currentThread().getName())); buffer.clear(); channel.read(buffer, channel, new Reader(buffer)); &#125; public void failed(Throwable exception, AsynchronousSocketChannel channel) &#123; throw new RuntimeException(exception); &#125; &#125; public static void main(String[] args) throws IOException, InterruptedException&#123; new AsyncEchoServer().start(); while(true)&#123; Thread.sleep(1000L); &#125; &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>NIO2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡]]></title>
    <url>%2F2017%2F06%2F03%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[DNS DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。 下图展示百度有三个IP地址： 优点: 可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。 动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。 缺点: 没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。 策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。 如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。 DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。 基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。 HTTP重定向 当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。 吞吐率限制主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。 重定向访问深度不同有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。 我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。 LVS（四层）以下内容参考自LVS NAT通过将请求报文的目标地址和目标端口修改为挑选出的某RS的RIP和PORT实现转发；特点： RIP和DIP必须在同一IP网络,且使用私网地址RS的网关应该指向DIP(保证响应报文必须经由VS) 请求和响应报文都要经由director转发；极高负载的场景中，Director可能会成为系统性能瓶颈 支持端口映射 VS必须为Linux，RS可以是任意的OS 调度器上需要两块网卡,一个配置vip 一个配置dip FULLNAT非标准模型, ipvs默认不支持,ipvsadm也不支持。NAT模式的扩展（阿里云的四层SLB使用的是此方式，因为此种方式下负载均衡器和后端服务器的部署不需要部署在同一网络内）通过同时修改请求报文的源IP地址（cip–&gt;dip）和目标IP地址（vip –&gt; rip）实现转发特点： 调度器和后端服务器可以不在同一IP网络中 RS收到的请求报文的源IP为DIP，因此其响应报文将发送给DIP； 请求报文和响应报文都必须经由director； 支持端口映射； RS可使用任意OS； DR直接路由通过为请求报文重新封装一个MAC首部进行转发,源MAC是DIP所在接口的MAC,目标MAC是挑选出的某RS的RIP所在接口的MAC地址；IP首部不会发生变化（源IP为CIP，目标IP始终为VIP） RS跟Director必须在同一物理网络中；RS的网关必须不能指向DIP 请求报文必须由Director调度，但响应报文必须不能经由Director 不支持端口映射 各RS可以使用大多数的OS；一般是linux 情形1: RIP DIP VIP 都在一个网络, 都是公网IP 地址 情形2: VIP 是公网ip地址, RIP,DIP是私有地址, 情况要复制些, RS要通过另一个路由出去 注意:一个路由其可以有多个网络接口一个交换机可以承载多个ip网络所以路由器1和路由器2可以使用同一个私网交换机和公网交换机也可以用同一个 TUNip tunnel，ip隧道转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而是在原有的IP首部之外再次封装一个IP首部（源IP为DIP，目标IP为RIP） RIP，DIP，VIP全得是公网地址 RS的网关不能也不可能指向DIP 请求报文经由Director调度，但响应报文将直接发给CIP 不支持端口映射 RS的OS必须支持IP隧道功能； 容易超出MTU, 弊端比较大 反向代理（七层）这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色： 任何对于实际服务器的HTTP请求都必须经过调度器 调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户） 优点： 调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。 对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。 反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。 反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。 缺点：反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。硬件一般工作在四层。性能较高，但是价格昂贵。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>technology</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构的八荣八耻和20个能力]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚石塔]]></title>
    <url>%2F2017%2F06%2F03%2F%E8%81%9A%E7%9F%B3%E5%A1%94%2F</url>
    <content type="text"><![CDATA[遵循互联网架构“八荣八耻”，解析EWS高质量架构6个维度的20个能力，本文简单介绍了聚石塔和EWS。 聚石塔是阿里为卖家系统提供的云计算环境，该云环境在全球提供了相应的负载均衡、安全、计算、存储等解决方案。卖家利用聚石塔的基础设施和服务可以快速搭建一套性能优越、扩容简单、资源弹性伸缩、容灾强、支持多活的系统，聚石塔的功能是赋能商家。EWS(Enterprise Workstation)，是聚石塔中的企业工作站，下图是EWS的系统总架构图。]]></content>
      <categories>
        <category>ali</category>
      </categories>
      <tags>
        <tag>architecture</tag>
        <tag>technology</tag>
      </tags>
  </entry>
</search>