<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JDK源码之编译]]></title>
    <url>%2F2017%2F06%2F05%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[本文主要说明如何编译组成rt.jar的源码，不涉及JVM的编译。 rt.jarrt.jar也就是运行时相关的class类，安装的jre里面的rt.jar是不能被debug的，为了对JDK的源码进行debug跟踪，需要重新编译rt.jar。rt.jar的全部源码在openjdk的jdk目录下，具体的路径是openjdk\jdk\src\，源码根据操作系统的不同和是否共享分成几个目录。实际上rt.jar因为操作系统的不同，所包含的class也会有所不同，这导致在一些特殊特性上JAVA不再是“一次编译，到处执行”。比如，在java7中，linux/unix下的jre支持com.sun.java.swing.plaf.gtk.GTKLookAndFeel,但是windows就不支持。操作系统安装的JDK里面的src.zip不包含sun.*包，sun.\包在openjdk源码里面,具体的路径是：jdk\src\share\classes。 openjdk的目录说明和源码下载参见：openjdk目录 编译本文编译的是openjdk-7里面jdk目录下的源码。 新建java project 将openjdk源码copy到project中。除了复制share目录下的共享源码，还需要复制具体操作系统下的源码。 编译导出jar。 参考资料：怎么对jdk核心包进行跟踪调试，并查看调试中的变量值]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[openjdk源码目录]]></title>
    <url>%2F2017%2F06%2F05%2Fopenjdk%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[本文主要参考自：openjdk源码结构 源码下载openjdk-7的源码：openjdk7源码openjdk-8的源码：openJDK8源码 目录说明openjdk的源码的目录结构如下图所示： 各个目录的说明如下：—— corba：不流行的多语言、分布式通讯接口—— hotspot：Java 虚拟机—— jaxp：XML 处理—— jaxws：一组 XML web services 的 Java API—— jdk：java 开发工具包—— —— 针对操作系统的部分—— —— share：与平台无关的实现—— langtools：Java 语言工具—— nashorn：JVM 上的 JavaScript 运行时 为了让大家易于理解，有所简化了结构。 Corba全称 Common Object Request Broker Architecture，通用对象请求代理架构，是基于 对象-服务 机制设计得。 与 JavaBean、COM 等是同种范畴。 目前，通用的远程过程调用协议是 SOAP（Simple Object Access Protocol，简单对象访问协议），消息格式是 XML-RPC（存在 Json-RPC）。另外，Apache Thrift 提供了多语言 C/S 通讯支持； 不少语言也内置了跨语言调用或对分布式环境友好，比如： lua 可以与 c 代码互调用，Go 可以调用 C 代码，erlang 在本地操作与分布式环境下的操作方法一样等。Corba和RMI类似，都能实现RPC。但是RMI只是针对JAVA环境的，Corba是支持多语言的方案 Hotspot全称 Java HotSpot Performance Engine，是 Java 虚拟机的一个实现，包含了服务器版和桌面应用程序版。利用 JIT 及自适应优化技术（自动查找性能热点并进行动态优化）来提高性能。 使用 java -version 可以查看 Hotspot 的版本。 从 Java 1.3 起为默认虚拟机，现由 Oracle 维护并发布。 其他 java 虚拟机： JRockit：专注于服务器端，曾经号称是“世界上速度最快的 Java 虚拟机”，现归于 Oracle 旗下。 J9：IBM 设计的 Java 虚拟机。 Harmony：Apache 的顶级项目之一，从 2011 年 11 月 6 日起入驻 Apache 的 Java 项目。虽然其能够兼容 jdk，但由于 JCP （Java Community Process）仅仅允许授权给 Harmony 一个带有限制条件的TCK（Technology Compatibility Kit），即仅仅能使用在 J2SE ,而不是所有Java实现上（包括 J2ME 和 J2EE），导致了 Apache 组织与 Oracle 的决裂。Harmony 是 Android 虚拟机 Dalvik 的前身。 Dalvik 并不是 Java 虚拟机，它执行的是 dex 文件而不是 class 文件，使用的也是寄存器架构而不是栈架构 。 jaxp全称 Java API for XML Processing，处理 XML 的Java API，是 Java XML 程序设计的应用程序接口之一，它提供解析和验证XML文档的能力。jaxp 提供了处理 xml 文件的三种接口： DOM 接口（文档对象模型解析），位于 \openjdk\jaxp\src\org\w3c\dom SAX 接口（xml 简单 api 解析），位于 \openjdk\jaxp\src\org\xml\sax StAX 接口（xml 流 api），位于 \openjdk\jaxp\src\javax\xml 除了解析接口，JAXP还提供了XSLT接口用来对XML文档进行数据和结构的转换。 JaxWS全称 Java API for Web Services，JAX-WS 允许开发者选择 RPC-oriented（面向 RPC） 或者 message-oriented（消息通信，erlang 使用的就是消息通信，不过 Java 内存模型是内存共享）来实现自己的web services。 通过 Web Services 提供的环境，可以实现 Java 与其他编程语言的交互（事实上就是 thrift 所做的，任何一种语言都可以通过 Web Services 实现与其他语言的通信，客户端用一种语言，服务器端可以用其他语言）。 LangToolsJava 语言支持工具 JDK全称 Java Development Kit。 share classes 目录里的是 Java 的实现，native 目录里的是 C++ 的实现，两部分基本对应。这两个目录里的结构与 java 的包也是对应，各个部分的用途另外再讲。 back、instrument、javavm、npt、transport 几个部分是实现 java 的基础部分，都是 C++ 代码，在这里从最底层理解 java，往后这些内容也会详讲。 sample 和 demo 目录有以下示例，区别在于 demo 目录是 针对 applets 的。 NashornNashorn 项目的目的是基于 Java 在 JVM 上实现一个轻量级高性能的 JavaScript 运行环境。基于 JSR-223 协议，Java 程序员可在 Java 程序中嵌入 JavaScript 代码。该项目使用了 JSR-229 里描述的新连接机制（从 Java7起开始使用的连接机制）：新的字节码（invokedynamic）以及新的基于方法句柄（method handle）的连接机制。通过接口注入（interface injection）在运行时修改类也是 JSR-229 里的内容。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA IO]]></title>
    <url>%2F2017%2F06%2F04%2FJAVA-IO%2F</url>
    <content type="text"><![CDATA[计算机IO本部分内容主要参考自《JAVA NIO》的第一章简介。 缓冲区操作下图简单描述了数据从外部磁盘向运行中的进程的内存区域移动的过程。进程使用 read( )系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，这一步通过 DMA 完成，无需主 CPU 协助。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行 read()调用时指定的缓冲区。 为什么不让磁盘控制器直接将磁盘上数据直接copy到用户缓冲区呢？ 硬件无法直接访问用户空间 像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责数据的分解、再组合工作，因此充当着中间人的角色。 发散和汇聚根据发散／汇聚的概念，进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来（如下图所示）。优点： 这样用户进程就不必多次执行系统调用（那样做可能代价不菲） 内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。 如果系统配有多个 CPU，甚至可以同时填充或排干多个缓冲区。 多个缓冲区可能方便一些特定协议的编程（自己加的）。 虚拟内存现代操作系统都支持虚拟内存，CPU为了更好的支持虚拟内存也加入了MMU（内存管理单元）。在寻址时，需要把虚拟地址经过MMU计算得到真实的物理地址，然后再去寻址。虚拟内存的好处： 一个以上的虚拟地址可指向同一个物理内存地址。 虚拟内存空间可大于实际可用的硬件内存。 内存页面调度为了支持虚拟内存，需要把内存存储到硬盘上，现代操作系统是通过内存页面调度实现的。对于采用分页技术的现代操作系统而言，这也是数据在磁盘与物理内存之间往来的唯一方式。下面的步骤说明了内存页面调度的过程： 当 CPU 引用某内存地址时，MMU负责确定该地址所在页（往往通过对地址值进行移位或屏蔽位操作实现），并将虚拟页号转换为物理页号（这一步由硬件完成，速度极快）。如果当前不存在与该虚拟页形成有效映射的物理内存页，MMU 会向 CPU 提交一个页错误。 页错误随即产生一个陷阱（类似于系统调用），把控制权移交给内核，附带导致错误的虚拟地址信息，然后内核采取步骤验证页的有效性。内核会安排页面调入操作，把缺失的页内容读回物理内存。这往往导致别的页被移出物理内存，好给新来的页让地方。在这种情况下，如果待移出的页已经被碰过了（自创建或上次页面调入以来，内容已发生改变），还必须首先执行页面调出，把页内容拷贝到磁盘上的分页区。 如果所要求的地址不是有效的虚拟内存地址（不属于正在执行的进程的任何一个内存段），则该页不能通过验证，段错误随即产生。于是，控制权转交给内核的另一部分，通常导致的结果就是进程被强令关闭。一旦出错的页通过了验证，MMU 随即更新，建立新的虚拟到物理的映射（如有必要，中断被移出页的映射），用户进程得以继续。造成页错误的用户进程对此不会有丝毫察觉，一切都在不知不觉中进行。 文件IO虚拟内存通过页面调度可以调度内存页和硬盘页，现代操作系统对文件IO的操作也是基于页面调度实现的。采用分页技术的操作系统执行 I/O 的全过程可总结为以下几步： 确定请求的数据分布在文件系统的哪些页（磁盘扇区组）。磁盘上的文件内容和元数据可能跨越多个文件系统页，而且这些页可能也不连续。 在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。 在内存页与磁盘上的文件系统页之间建立映射。 为每一个内存页产生页错误。 虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。 一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。 内存映射文件为了在内核空间的文件系统页与用户空间的内存区之间移动数据，一次以上的拷贝操作几乎总是免不了的。这是因为，在文件系统页与用户缓冲区之间往往没有一一对应关系。但是，还有一种大多数操作系统都支持的特殊类型的 I/O 操作，允许用户进程最大限度地利用面向页的系统 I/O 特性，并完全摒弃缓冲区拷贝。这就是内存映射 I/O。内存映射文件将内存页全部映射到文件的硬盘块上，存在一一映射关系。使用内存映射文件时，用户态是没有缓冲区的，只存在映射到硬盘页的内存页面缓冲区，所以是真正的ZeroCopy。而不使用内存映射文件的IO，因为直接内存和内存页缓冲区没有映射关系，所以使使用直接内存作为缓冲区也是需要最少一次copy的。（那文件IO时使用直接内存的好处是什么？） 文件锁定JVM实现的是进程之间的锁定，一个进程之间的多个线程之间是不锁定的。支持共享锁、独占锁等支持锁定文件的部分区域，粒度支持到字节。 流IO流的传输一般（也不必然如此）比块设备慢，经常用于间歇性输入。多数操作系统允许把流置于非块模式，这样，进程可以查看流上是否有输入，即便当时没有也不影响它干别的。这样一种能力使得进程可以在有输入的时候进行处理，输入流闲置的时候执行其他功能。处理流IO需要依赖操作系统的通知机制： Selector通知已就绪，可以进行相关IO操作。 AIO通知IO操作已完成，可以处理相关业务逻辑了。 JAVA IO 发展和总结BIO 抽象工作良好，适应用途广泛。但是当移动大量数据时，这些 I/O 类可伸缩性不强，也没有提供当今大多数操作系统普遍具备的常用 I/O 功能，如文件锁定、非块 I/O、就绪性选择和内存映射。这些特性对实现可伸缩性是至关重要的，对保持与非 Java 应用程序的正常交互也可以说是必不可少的，尤其是在企业应用层面，而传统的 Java I/O 机制却没有模拟这些通用 I/O 服务。操作系统与 Java 基于流的 I/O模型有些不匹配。操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（DMA）的协助下完成的。BIO 类喜欢操作小块数据——单个字节、几行文本。 BIOJDK版本：1.1时间：特点： 同步阻塞 面向流（字节流和字符流） 不支持操作系统支持的很多IO概念和特性 read()操作返回所读的字节数，write操作没有返回值 read是SeekAble的（支持skip），write不是Seekable的。 NIO.1JDK版本：1.4时间：2002特点： 针对现代操作系统重新抽象和封装实现了Channel和Buffer 网络IO支持配置是否阻塞，文件IO只能是阻塞的 网络IO支持多路复用（异步），使用多路复用时，Channel必须是非阻塞模式，而且阻塞模式不能再被修改 网络IO和文件IO都是可中断的。文件IO过程中被中断时，JVM会关闭Channel。 支持直接Buffer、支持内存映射文件 支持文件锁定，但是是进程级别的锁定 支持Pipe read操作返回所读的字节数，write操作返回所写的字节数 Channel是全双工的。虽然RandomAccessFile也可以是全双工的，但是Channel这种封装方式更好 NIO.2（AIO）JDK版本：1.7时间：2011特点： 文件IO和网络IO是异步的（当然是非阻塞的），异步形式是future和callback。 Watch Service 文件IO支持更丰富的API BIONIO.1NIO.2异步Watch ServiceIO更丰富的文件操作]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>IO,JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pro Java 7 NIO 2读书笔记]]></title>
    <url>%2F2017%2F06%2F04%2FPro-Java-7-NIO-2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[转自 花了几天把这本书初略的看了一下， 之所以初略的看了一下，是因为这书里确实没啥内容。如果去了NIO 1的内容和大段大段的代码， 基本上压缩到50页应该没问题。 下面简单的罗列一下看到的内容： Path这个类在java.nio.file，在NIO里对文件系统进行了进一步的抽象。 是用来替换原来的java.io.File。其中 FileSystems, Files, Path, PathMatcher 成为一个体系。 在java7里File和Path可以相互转换： File.toPath(), Path.toFile()原来的File里包含了文件引用和文件，在Path系统里， Path里是文件的引用，而文件操作都放到了Files的静态方法里。这种方式究竟好不好用，我没啥感觉。不过我个人偏向于把操作放到另外一个类里面。 获得Path实例的方式：File.toPath(), Paths.get(), FileSystem.getPath() 注意： Path和File一样，能创建出实例不代表着这个文件一定在文件系统里真是存在。 Path和File相比使用上方便了的地方： 不用特意指定路径的separator：Paths.get(&quot;C:&quot;,&quot;folder1&quot;,&quot;subfolder&quot;,&quot;aa.txt&quot;) 在windows系统了是C:\folder1\subfolder\aa.txt在Mac下是C:/folder/subfolder/aa.txtJava会根据当前操作系统来决定separator 重复利用基本路径：12345678910//define the fixed pathPath base = Paths.get("C:/rafaelnadal/tournaments/2009");//resolve BNP.txt filePath path_1 = base.resolve("BNP.txt");//output: C:\rafaelnadal\tournaments\2009\BNP.txtSystem.out.println(path_1.toString());//resolve AEGON.txt filePath path_2 = base.resolve("AEGON.txt");//output: C:\rafaelnadal\tournaments\2009\AEGON.txtSystem.out.println(path_2.toString()); 而resolveSibling方法更加好用：可以直接获取相同目录下的其他文件：123456//define the fixed pathPath base = Paths.get("C:/rafaelnadal/tournaments/2009/BNP.txt");//resolve sibling AEGON.txt filePath path = base.resolveSibling("AEGON.txt");//output: C:\rafaelnadal\tournaments\2009\AEGON.txtSystem.out.println(path.toString()); 取得相对路径：假设BNP.txt和AEGON.txt在同一目录下123456789Path path01 = Paths.get("BNP.txt");Path path02 = Paths.get("AEGON.txt");//output: ..\AEGON.txtPath path01_to_path02 = path01.relativize(path02);System.out.println(path01_to_path02);//output: ..\BNP.txtPath path02_to_path01 = path02.relativize(path01);System.out.println(path02_to_path01); 假设：12Path path01 = Paths.get("/tournaments/2009/BNP.txt");Path path02 = Paths.get("/tournaments/2011"); 那么：123456//output: ..\..\2011Path path01_to_path02 = path01.relativize(path02);System.out.println(path01_to_path02);//output: ..\2009\BNP.txtPath path02_to_path01 = path02.relativize(path01);System.out.println(path02_to_path01); 遍历：Path实现了Iterable接口，也就是说我们可以这样：1234Path path = Paths.get("C:", "rafaelnadal/tournaments/2009", "BNP.txt");for (Path name : path) &#123; System.out.println(name);&#125; 猜猜结果是什么？我一开始以为是吧目录下的文件遍历出来呢。结果是这样的：rafaelnadaltournaments2009BNP.txt说实话，我觉得这个比较坑爹！ 文件属性java.nio.file.attribute包下的类提供了获取文件属性的类，针对不同操作系统使用的类不太一样，当然也有所有操作系统通用的属性。 属性分类有一些几种：BasicFileAttributeViewDosFileAttributeViewPosixFileAttributeViewFileOwnerAttributeViewAclFileAttributeViewUserDefinedFileAttributeView 获取属性：123456789101112131415BasicFileAttributes attr = null;Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "BNP.txt");try &#123; attr = Files.readAttributes(path, BasicFileAttributes.class);&#125; catch (IOException e) &#123; System.err.println(e);&#125;System.out.println("File size: " + attr.size());System.out.println("File creation time: " + attr.creationTime());System.out.println("File was last accessed at: " + attr.lastAccessTime());System.out.println("File was last modified at: " + attr.lastModifiedTime());System.out.println("Is directory? " + attr.isDirectory());System.out.println("Is regular file? " + attr.isRegularFile());System.out.println("Is symbolic link? " + attr.isSymbolicLink());System.out.println("Is other? " + attr.isOther()); 或 long size = (Long)Files.getAttribute(path, &quot;basic:size&quot;, NOFOLLOW_LINKS); 设置属性：123456789Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "BNP.txt");long time = System.currentTimeMillis();FileTime fileTime = FileTime.fromMillis(time);try &#123; Files.getFileAttributeView(path, BasicFileAttributeView.class).setTimes(fileTime, fileTime, fileTime);&#125; catch (IOException e) &#123; System.err.println(e);&#125; 或1234567long time = System.currentTimeMillis();FileTime fileTime = FileTime.fromMillis(time);try &#123; Files.setLastModifiedTime(path, fileTime);&#125; catch (IOException e) &#123; System.err.println(e);&#125; Symbolic和Hard Links相同于用Java程序实现linux下的 ln命令。123Path link = FileSystems.getDefault().getPath("rafael.nadal.1");Path target= FileSystems.getDefault().getPath("C:/rafaelnadal/photos", "rafa_winner.jpg");Files.createSymbolicLink(link, target); DirectoryStream这也是一个比较有用的类：用来遍历路径下的子路径或文件，而且支持通配符过滤。1234567891011Path path = Paths.get("C:/rafaelnadal/tournaments/2009");…//glob pattern appliedSystem.out.println("\nGlob pattern applied:");try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path, "*.&#123;png,jpg,bmp&#125;")) &#123; for (Path file : ds) &#123; System.out.println(file.getFileName()); &#125;&#125; catch (IOException e) &#123; System.err.println(e);&#125; FileVisitor和Files.walkFileTreeFileVisitor是一个接口，Files.walkFileTree是一个方法。 通过两者的配合可以遍历整个某个路径下的所有子路径和文件。没有这个之前我们用递归方法也能实现，有了这个不能说是现实更加容易， 只能说是现实更加规范， 如果大家都用这个，代码的可维护性会更好。我觉得仅此而已。 FileVisitor有四个方法 FileVisitResult postVisitDirectory(T dir, IOException exc)Invoked for a directory after entries in the directory, and all of their descendants, have been visited. FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) Invoked for a directory before entries in the directory are visited.+FileVisitResult visitFile(T file, BasicFileAttributes attrs) Invoked for a file in a directory. FileVisitResult visitFileFailed(T file, IOException exc) Invoked for a file that could not be visited. FileVisitResult枚举类型：CONTINUE，SKIP_SIBLINGS，SKIP_SUBTREE，TERMINATE Watch Service API这是NIO2里比较重要的一个新增功能， 以前直接用java监视文件系统的变化是不可能的，只能通过jni的方式调用操作系统的api来对文件系统进行监视。在java7里这部分被加到了标准库里，这样我们就不能在去寻找jni的结果方案了。但是事实上为了保持java的扩平台特性，监控的功能范围被定为各个操作系统的交集，所以没有特殊的情况还是需要直接调用操作系统的api来实现。1234567891011121314151617181920212223242526272829303132public void watchRNDir(Path path) throws IOException, InterruptedException &#123; try (WatchService watchService = FileSystems.getDefault().newWatchService()) &#123; path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE); //start an infinite loop while (true) &#123; //retrieve and remove the next watch key final WatchKey key = watchService.take(); //get list of pending events for the watch key for (WatchEvent&lt;?&gt; watchEvent : key.pollEvents()) &#123; //get the kind of event (create, modify, delete) final Kind&lt;?&gt; kind = watchEvent.kind(); //handle OVERFLOW event if (kind == StandardWatchEventKinds.OVERFLOW) &#123; continue; &#125; //get the filename for the event final WatchEvent&lt;Path&gt; watchEventPath = (WatchEvent&lt;Path&gt;) watchEvent; final Path filename = watchEventPath.context(); //print it out System.out.println(kind + " -&gt; " + filename); &#125; //reset the key boolean valid = key.reset(); //exit loop if the key is not valid (if the directory was deleted, for example) if (!valid) &#123; break; &#125; &#125; &#125;&#125; Random Access Files主要是提供了一个SeekableByteChannel接口，配合ByteBuffer使随机访问文件更加方便。12345678910111213141516171819202122232425262728Path path = Paths.get("C:/rafaelnadal/tournaments/2009", "MovistarOpen.txt");ByteBuffer buffer = ByteBuffer.allocate(1);String encoding = System.getProperty("file.encoding");try (SeekableByteChannel seekableByteChannel = (Files.newByteChannel(path, EnumSet.of(StandardOpenOption.READ)))) &#123; //the initial position should be 0 anyway seekableByteChannel.position(0); System.out.println("Reading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.rewind(); //get into the middle seekableByteChannel.position(seekableByteChannel.size()/2); System.out.println("\nReading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.rewind(); //get to the end seekableByteChannel.position(seekableByteChannel.size()-1); System.out.println("\nReading one character from position: " + seekableByteChannel.position()); seekableByteChannel.read(buffer); buffer.flip(); System.out.print(Charset.forName(encoding).decode(buffer)); buffer.clear();&#125; catch (IOException ex) &#123; System.err.println(ex);&#125; Asynchronous Channel API这个是NIO2的较大的变化，有原来的Selecor方法变成方法回调模式。使用上更加方便。并且文件的读写也可以异步的方式实现了。 异步读取文件 ：12345678910111213141516171819202122232425262728ByteBuffer buffer = ByteBuffer.allocate(100);Path path = Paths.get("C:/rafaelnadal/grandslam/RolandGarros", "story.txt");try (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123; current = Thread.currentThread(); asynchronousFileChannel.read(buffer, 0, "Read operation status ...", new CompletionHandler&lt;Integer, Object&gt;() &#123; @Override public void completed(Integer result, Object attachment) &#123; System.out.println(attachment); System.out.print("Read bytes: " + result); current.interrupt(); &#125; @Override public void failed(Throwable exc, Object attachment) &#123; System.out.println(attachment); System.out.println("Error:" + exc); current.interrupt(); &#125; &#125;); System.out.println("\nWaiting for reading operation to end ...\n"); try &#123; current.join(); &#125; catch (InterruptedException e) &#123; &#125; //now the buffer contains the read bytes System.out.println("\n\nClose everything and leave! Bye, bye ...");&#125; catch (Exception ex) &#123; System.err.println(ex);&#125; 异步socket服务器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class AsyncEchoServer &#123; private AsynchronousServerSocketChannel serverChannel; public void start() throws IOException &#123; System.out.println(String.format("start: name: %s", Thread.currentThread().getName())); serverChannel = AsynchronousServerSocketChannel.open(); serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, true); serverChannel.bind(new InetSocketAddress(8000)); serverChannel.accept(serverChannel, new Acceptor()); &#125; class Acceptor implements CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt; &#123; private final ByteBuffer buffer = ByteBuffer.allocate(1024); public Acceptor()&#123; System.out.println("an acceptor has created."); &#125; public void completed(final AsynchronousSocketChannel channel, AsynchronousServerSocketChannel serverChannel) &#123; System.out.println(String.format("write: name: %s", Thread.currentThread().getName())); channel.read(buffer, channel, new Reader(buffer)); serverChannel.accept(serverChannel, new Acceptor()); &#125; public void failed(Throwable exception, AsynchronousServerSocketChannel serverChannel) &#123; throw new RuntimeException(exception); &#125; &#125; class Reader implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; &#123; private ByteBuffer buffer; public Reader(ByteBuffer buffer)&#123; this.buffer = buffer; &#125; public void completed(Integer result, AsynchronousSocketChannel channel)&#123; System.out.println(String.format("read: name: %s", Thread.currentThread().getName())); if(result != null &amp;&amp; result &lt; 0)&#123; try&#123; channel.close(); return; &#125;catch(IOException ignore)&#123;&#125; &#125; buffer.flip(); channel.write(buffer, channel, new Writer(buffer)); &#125; public void failed(Throwable exception, AsynchronousSocketChannel channel)&#123; throw new RuntimeException(exception); &#125; &#125; class Writer implements CompletionHandler&lt;Integer, AsynchronousSocketChannel&gt; &#123; private ByteBuffer buffer; public Writer(ByteBuffer buffer)&#123; this.buffer = buffer; &#125; public void completed(Integer result, AsynchronousSocketChannel channel) &#123; System.out.println(String.format("write: name: %s", Thread.currentThread().getName())); buffer.clear(); channel.read(buffer, channel, new Reader(buffer)); &#125; public void failed(Throwable exception, AsynchronousSocketChannel channel) &#123; throw new RuntimeException(exception); &#125; &#125; public static void main(String[] args) throws IOException, InterruptedException&#123; new AsyncEchoServer().start(); while(true)&#123; Thread.sleep(1000L); &#125; &#125;&#125;]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>NIO2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[负载均衡]]></title>
    <url>%2F2017%2F06%2F03%2F%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%2F</url>
    <content type="text"><![CDATA[DNS DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。 下图展示百度有三个IP地址： 优点: 可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。 动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。 缺点: 没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。 策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。 如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。 DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。 基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。 HTTP重定向 当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。 吞吐率限制主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。 重定向访问深度不同有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。 我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。 LVS（四层）以下内容参考自LVS NAT通过将请求报文的目标地址和目标端口修改为挑选出的某RS的RIP和PORT实现转发；特点： RIP和DIP必须在同一IP网络,且使用私网地址RS的网关应该指向DIP(保证响应报文必须经由VS) 请求和响应报文都要经由director转发；极高负载的场景中，Director可能会成为系统性能瓶颈 支持端口映射 VS必须为Linux，RS可以是任意的OS 调度器上需要两块网卡,一个配置vip 一个配置dip FULLNAT非标准模型, ipvs默认不支持,ipvsadm也不支持。NAT模式的扩展（阿里云的四层SLB使用的是此方式，因为此种方式下负载均衡器和后端服务器的部署不需要部署在同一网络内）通过同时修改请求报文的源IP地址（cip–&gt;dip）和目标IP地址（vip –&gt; rip）实现转发特点： 调度器和后端服务器可以不在同一IP网络中 RS收到的请求报文的源IP为DIP，因此其响应报文将发送给DIP； 请求报文和响应报文都必须经由director； 支持端口映射； RS可使用任意OS； DR直接路由通过为请求报文重新封装一个MAC首部进行转发,源MAC是DIP所在接口的MAC,目标MAC是挑选出的某RS的RIP所在接口的MAC地址；IP首部不会发生变化（源IP为CIP，目标IP始终为VIP） RS跟Director必须在同一物理网络中；RS的网关必须不能指向DIP 请求报文必须由Director调度，但响应报文必须不能经由Director 不支持端口映射 各RS可以使用大多数的OS；一般是linux 情形1: RIP DIP VIP 都在一个网络, 都是公网IP 地址 情形2: VIP 是公网ip地址, RIP,DIP是私有地址, 情况要复制些, RS要通过另一个路由出去 注意:一个路由其可以有多个网络接口一个交换机可以承载多个ip网络所以路由器1和路由器2可以使用同一个私网交换机和公网交换机也可以用同一个 TUNip tunnel，ip隧道转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而是在原有的IP首部之外再次封装一个IP首部（源IP为DIP，目标IP为RIP） RIP，DIP，VIP全得是公网地址 RS的网关不能也不可能指向DIP 请求报文经由Director调度，但响应报文将直接发给CIP 不支持端口映射 RS的OS必须支持IP隧道功能； 容易超出MTU, 弊端比较大 反向代理（七层）这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色： 任何对于实际服务器的HTTP请求都必须经过调度器 调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户） 优点： 调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。 对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。 反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。 反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。 缺点：反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。硬件一般工作在四层。性能较高，但是价格昂贵。]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
        <tag>technology</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[架构的八荣八耻和20个能力]]></title>
    <url>%2F2017%2F06%2F03%2F%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>technology</category>
      </categories>
      <tags>
        <tag>architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚石塔]]></title>
    <url>%2F2017%2F06%2F03%2F%E8%81%9A%E7%9F%B3%E5%A1%94%2F</url>
    <content type="text"><![CDATA[遵循互联网架构“八荣八耻”，解析EWS高质量架构6个维度的20个能力，本文简单介绍了聚石塔和EWS。 聚石塔是阿里为卖家系统提供的云计算环境，该云环境在全球提供了相应的负载均衡、安全、计算、存储等解决方案。卖家利用聚石塔的基础设施和服务可以快速搭建一套性能优越、扩容简单、资源弹性伸缩、容灾强、支持多活的系统，聚石塔的功能是赋能商家。EWS(Enterprise Workstation)，是聚石塔中的企业工作站，下图是EWS的系统总架构图。]]></content>
      <categories>
        <category>ali</category>
      </categories>
      <tags>
        <tag>architecture</tag>
        <tag>technology</tag>
      </tags>
  </entry>
</search>