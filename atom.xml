<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YDDMAX</title>
  <subtitle>代码奔腾</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://YDDMAX.github.io/"/>
  <updated>2017-06-14T15:01:42.228Z</updated>
  <id>http://YDDMAX.github.io/</id>
  
  <author>
    <name>yunzhu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Channel</title>
    <link href="http://YDDMAX.github.io/2017/06/14/Channel/"/>
    <id>http://YDDMAX.github.io/2017/06/14/Channel/</id>
    <published>2017-06-14T14:59:47.000Z</published>
    <updated>2017-06-14T15:01:42.228Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文内容主要摘录自：《JAVA NIO》。</strong></p>
<p>Channel的类图如下：<br><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/Channel-class.png" alt="Channel-class"></p>
<h1 id="通道基础"><a href="#通道基础" class="headerlink" title="通道基础"></a>通道基础</h1><ol>
<li>从 Channel 接口引申出的其他接口都是面向字节的子接口，包括 WritableByteChannel和ReadableByteChannel.这也正好支持了我们之前所学的：通道只能在字节缓冲区上操作。</li>
<li>SelectableChannel和InterruptibleChannel<h2 id="打开通道"><a href="#打开通道" class="headerlink" title="打开通道"></a>打开通道</h2></li>
</ol>
<ul>
<li><code>SocketChannel sc = SocketChannel.open( );</code></li>
<li><code>ServerSocketChannel ssc = ServerSocketChannel.open( );</code></li>
<li><code>DatagramChannel dc = DatagramChannel.open( );</code></li>
<li>RandomAccessFile、 FileInputStream 或 FileOutputStream对象上调用 getChannel( )方法来获取<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile (<span class="string">"somefile"</span>, <span class="string">"r"</span>);</div><div class="line">FileChannel fc = raf.getChannel( );</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="使用通道"><a href="#使用通道" class="headerlink" title="使用通道"></a>使用通道</h2><ol>
<li>通道可以是单向的，也可以是双向的，由底层的打开方式决定。</li>
<li>ByteChannel 接口本身并不定义新的 API 方法，它是一种用来聚集它自己以一个新名称继承的多个接口的便捷接口。</li>
<li><strong>通道可以以阻塞（blocking）或非阻塞（nonblocking）模式运行。</strong>非阻塞模式的通道永远不会让调用的线程休眠。请求操作要么立即完成，要么返回一个结果表明未进行任何操作。<br> <strong>只有面向流的（stream-oriented）的通道，如 sockets 和 pipes 才能使用非阻塞模式。</strong><h2 id="关闭通道"><a href="#关闭通道" class="headerlink" title="关闭通道"></a>关闭通道</h2></li>
<li><strong>调用通道的close( )方法时，可能会导致在通道关闭底层I/O服务的过程中线程暂时阻塞,哪怕该通道处于非阻塞模式。</strong><br> 通道关闭时的阻塞行为（如果有的话）是高度取决于操作系统或者文件系统的。<strong>在一个通道上多次调用close( )方法是没有坏处的</strong>，但是如果第一个线程在close( )方法中阻塞，那么在它完成关闭通道之前，任何其他调用close( )方法都会阻塞。后续在该已关闭的通道上调用close( )不会产生任何操作，只会立即返回。</li>
<li>通道引入了一些与<strong>关闭和中断有关的新行为</strong>。<br> 如果一个通道实现 InterruptibleChannel接口，它的行为以下述语义为准：<strong>如果一个线程在一个通道上被阻塞并且同时被中断（由调用该被阻塞线程的 interrupt( )方法的另一个线程中断），那么该通道将被关闭，该被阻塞线程也会产生一个 ClosedByInterruptException 异常。</strong></li>
<li><strong>请不要将在 Channels 上休眠的中断线程同在 Selectors上休眠的中断线程混淆。前者会关闭通道，而后者则不会。</strong><br> 不过，如果您的线程在 Selector 上休眠时被中断，那它的 interrupt status 会被设置。假设那个线程接着又访问一个Channel，则该通道会被关闭。</li>
<li>仅仅因为休眠在其上的线程被中断就关闭通道，这看起来似乎过于苛刻了。<br> 不过这却是 NIO架构师们所做出的明确的设计决定。经验表明，想要在所有的操作系统上一致而可靠地处理被中断的 I/O操作是不可能的。 java.nio 包中强制使用此行为来避免因操作系统独特性而导致的困境，因为该困境对 I/O 区域而言是极其危险的。<strong>这也是为增强健壮性（robustness）而采用的一种经典的权衡。</strong></li>
<li><strong>可中断的通道也是可以异步关闭的。</strong><br> 实现 InterruptibleChannel 接口的通道可以在任何时候被关闭，即使有另一个被阻塞的线程在等待该通道上的一个 I/O 操作完成。当一个通道被关闭时，休眠在该通道上的所有线程都将被唤醒并接收到一个 AsynchronousCloseException异常。接着通道就被关闭并将不再可用。<h1 id="Scanner-Gather"><a href="#Scanner-Gather" class="headerlink" title="Scanner/Gather"></a>Scanner/Gather</h1>通道提供了一种被称为 Scatter/Gather的重要新功能（有时也被称为矢量 I/O）。 </li>
</ol>
<p>Scatter/Gather是一个简单却强大的概念，它是指在多个缓冲区上实现一个简单的 I/O 操作。<br><strong>对于一个 write 操作而言</strong>，数据是从几个缓冲区按顺序抽取（称为 gather）并沿着通道发送的。缓冲区本身并不需要具备这种 gather 的能力（通常它们也没有此能力）。该 gather过程的效果就好比全部缓冲区的内容被连结起来，并在发送数据前存放到一个大的缓冲区中。<br><strong>对于 read 操作而言</strong>，从通道读取的数据会按顺序被散布（称为 scatter）到多个缓冲区，将每个缓冲区填满直至通道中的数63据或者缓冲区的最大空间被消耗完。大多数现代操作系统都支持本地矢量 I/O（native vectored I/O）。当您在一个通道上请求一个Scatter/Gather操作时，该请求会被翻译为适当的本地调用来直接填充或抽取缓冲区。这是一个很大的进步，因为减少或避免了缓冲区拷贝和系统调用。 </p>
<p>Scanner:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScatteringByteChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">ReadableByteChannel</span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Gather:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GatheringByteChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">WritableByteChannel</span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用得当的话， <strong>Scatter/Gather 会是一个极其强大的工具。它允许您委托操作系统来完成辛苦活：将读取到的数据分开存放到多个存储桶（bucket）或者将不同的数据区块合并成一个整体。这是一个巨大的成就，因为操作系统已经被高度优化来完成此类工作了。它节省了您来回移动数据的工作，也就<font color="red">避免了缓冲区拷贝(为啥？)</font>和减少了您需要编写、调试的代码数量。</strong></p>
<h1 id="文件通道"><a href="#文件通道" class="headerlink" title="文件通道"></a>文件通道</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/FileChanel-class.png" alt="Filechannel-class"></p>
<ol>
<li>文件通道总是阻塞式的，因此不能被置于非阻塞模式。<br> 现代操作系统都有复杂的缓存和预取机制，使得本地磁盘I/O操作延迟很少。网络文件系统一般而言延迟会多些，不过却也因该优化而受益。 <strong>面向流的 I/O的非阻塞范例对于面向文件的操作并无多大意义，这是由文件I/O本质上的不同性质造成的。</strong></li>
<li>FileChannel 对象是线程安全（thread-safe）的。</li>
<li>File IO的比较<br> <img src="http://oqxil93b6.bkt.clouddn.com/images/IO/file-io-operation-compare.png" alt="file-io-opeartion-compare"></li>
<li><p>FileChannel原型：<br> 如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannel</span></span></div><div class="line">    <span class="keyword">extends</span> <span class="title">AbstractChannel</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">GatheringByteChannel</span>, <span class="title">ScatteringByteChannel</span></div><div class="line">    &#123;</div><div class="line">    <span class="comment">// This is a partial API listing</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">position</span><span class="params">( )</span></span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">position</span> <span class="params">(<span class="keyword">long</span> newPosition)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst, <span class="keyword">long</span> position)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src, <span class="keyword">long</span> position)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">( )</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">truncate</span> <span class="params">(<span class="keyword">long</span> size)</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">force</span> <span class="params">(<span class="keyword">boolean</span> metaData)</span></div><div class="line">    &#125;</div><div class="line">    ```   </div><div class="line">    </div><div class="line">5.    文件空洞</div><div class="line">    当磁盘上一个文件的分配空间小于它的文件大小时会出现“文件空洞”。对于内容稀疏的文件，大多数现代文件系统只为实际写入的数据分配磁盘空间（更准确地说，只为那些写入数据的文件系统页分配空间）。假如数据被写入到文件中非连续的位置上，这将导致文件出现在逻辑上不包含数据的区域（即“空洞”）。**如果该文件被顺序读取的话，所有空洞都会被“0”填充但不占用磁盘空间。**</div><div class="line">6. <span class="title">truncate</span><span class="params">()</span></div><div class="line">    当需要减少一个文件的 size 时， <span class="title">truncate</span><span class="params">( )</span>方法会砍掉您所指定的新 size 值之外的所有数据。</div><div class="line">    如果当前 size 大于新 size，超出新 size 的所有字节都会被悄悄地丢弃。</div><div class="line">    如果提供的新 size 值大于或等于当前的文件 size 值，该文件不会被修改。</div><div class="line">   **这两种情况下， <span class="title">truncate</span><span class="params">( )</span>都会产生副作用：文件的position 会被设置为所提供的新 size 值。**</div><div class="line">## 文件锁定</div><div class="line">有关 FileChannel 实现的文件锁定模型的一个重要注意项是：**锁的对象是文件而不是通道或线程，这意味着文件锁不适用于判优同一台 Java 虚拟机上的多个线程发起的访问。**</div><div class="line">如果一个线程在某个文件上获得了一个独占锁，然后第二个线程利用一个单独打开的通道来请求该文件的独占锁，那么第二个线程的请求会被批准。</div><div class="line">但如果这两个线程运行在不同的 Java 虚拟机上，那么第二个线程会阻塞，因为锁最终是由操作系统或文件系统来判优的并且几乎总是在进程级而非线程级上判优。锁都是与一个文件关联的，而不是与单个的文件句柄或通道关联。锁与文件关联，而不是与通道关联。**我们使用锁来判优外部进程，而不是判优同一个 Java 虚拟机上的线程。**</div><div class="line">## 内存映射文件</div><div class="line">1. 因为不需要做明确的系统调用，那会很消耗时间。</div><div class="line">    更重要的是，操作系统的虚拟内存可以自动缓存内存页（memory page）。这些页是用系统内存来缓存的，所以不会消耗 Java 虚拟机内存堆（memory heap）。</div><div class="line">2. 与文件锁的范围机制不一样，映射文件的范围不应超过文件的实际大小。</div><div class="line">    **如果您请求一个超出文件大小的映射，文件会被增大以匹配映射的大小<span class="params">(文件空洞)</span>。**即使您请求的是一个只读映射，<span class="title">map</span><span class="params">( )</span>方法也会尝试这样做并且大多数情况下都会抛出一个 IOException 异常，因为底层的文件不能被修改。该行为同之前讨论的文件“空洞”的行为是一致的。</div><div class="line">3. MapMode.READ_ONLY </div><div class="line">4. MapMode.READ_WRITE </div><div class="line">5.  MapMode.<span class="title">PRIVATE</span><span class="params">(写时拷贝)</span></div><div class="line">    + 您通过 <span class="title">put</span><span class="params">( )</span>方法所做的任何修改都会导致产生一个私有的数据拷贝，并且该拷贝中的数据只有MappedByteBuffer 实例可以看到。该过程不会对底层文件做任何修改，而且一旦缓冲区被施以垃圾收集动作（garbage collected），那些修改都会丢失。</div><div class="line">    + **尽管写时拷贝的映射可以防止底层文件被修改，您也必须以 read/write 权限来打开文件**以建立 MapMode.PRIVATE 映射。只有这样，返回的MappedByteBuffer 对象才能允许使用 <span class="title">put</span><span class="params">( )</span>方法。</div><div class="line">    + 选择使用 MapMode.PRIVATE 模式并不会导致您的缓冲区看不到通过其他方式对文件所做的修改。</div><div class="line">        对文件某个区域的修改在使用 MapMode.PRIVATE模式的缓冲区中都能反映出来，除非该缓冲区已经修改了文件上的同一个区域。如果缓冲区还没对某个页做出修改，那么这个页就会反映被映射文件的相应位置上的内容。一旦某个页因为写操作而被拷贝，之后就将使用该拷贝页，并且不能被其他缓冲区或文件更新所修改。</div><div class="line">    + 关闭相关联的 FileChannel 不会破坏映射，只有丢弃缓冲区对象本身才会破坏该映射。</div><div class="line">        **NIO设计师们之所以做这样的决定是因为当关闭通道时破坏映射会引起安全问题，而解决该安全问题又会导致性能问题。** ***如果您确实需要知道一个映射是什么时候被破坏的，他们建议使用虚引用（phantomreferences，参见java.lang.ref.PhantomReference）和一个 cleanup 线程。***不过有此需要的概率是微乎其微的。</div><div class="line">6. <span class="title">load</span><span class="params">()</span></div><div class="line">    在一个映射缓冲区上调用 <span class="title">load</span><span class="params">()</span>方法会是一个**代价高**的操作，因为它会导致大量的页调入（page-in），具体数量取决于文件中被映射区域的实际大小。</div><div class="line">   **然而， <span class="title">load</span><span class="params">( )</span>方法返回并不能保证文件就会完全常驻内存，这是由于请求页面调入（demandpaging）是动态的。**具体结果会因某些因素而有所差异，这些因素包括：操作系统、文件系统，可用 Java 虚拟机内存，最大 Java 虚拟机内存，垃圾收集器实现过程等等。请小心使用 <span class="title">load</span><span class="params">( )</span>方法，它可能会导致您不希望出现的结果。该方法的主要作用是为提前加载文件埋单，以便后续的访问速度可以尽可能的快。</div><div class="line">7. <span class="title">isLoaded</span><span class="params">()</span></div><div class="line">     <span class="title">isLoaded</span><span class="params">( )</span>方法来判断一个被映射的文件是否完全常驻内存了。**不过，这也是不能保证的。**同样地，返回 <span class="keyword">false</span> 值并不一定意味着访问缓冲区将很慢或者该文件并未完全常驻内存。 <span class="title">isLoaded</span><span class="params">()</span>方法的返回值只是一个暗示，由于垃圾收集的异步性质、底层操作系统以及运行系统的动态性等因素，**想要在任意时刻准确判断全部映射页的状态是不可能的。**</div><div class="line">8. <span class="title">force</span><span class="params">()</span></div><div class="line">该方法会强制将映射缓冲区上的更改应用到永久磁盘存储器上。当用 MappedByteBuffer 对象来更新一个文件，**您应该总是使用 MappedByteBuffer.<span class="title">force</span><span class="params">( )</span>,而非 FileChannel.<span class="title">force</span><span class="params">( )</span>，因为通道对象可能不清楚通过映射缓冲区做出的文件的全部更改。**</div><div class="line">**MappedByteBuffer 没有不更新文件元数据的选项——元数据总是会同时被更新的。**</div><div class="line">**如果映射是以 MapMode.READ_ONLY 或 MAP_MODE.PRIVATE 模式建立的，那么调用 <span class="title">force</span><span class="params">()</span>方法将不起任何作用，因为永远不会有更改需要应用到磁盘上（但是这样做也是没有害处的）。**</div><div class="line">## Channel-to-Channel传输</div><div class="line">1. <span class="title">transferTo</span><span class="params">( )</span>和 <span class="title">transferFrom</span><span class="params">( )</span>方法允许将一个通道交叉连接到另一个通道，而不需要通过一个中间缓冲区来传递数据。</div><div class="line">2. **只有 FileChannel 类有这两个方法，因此 channel-to-channel 传输中通道之一必须是 FileChannel。您不能在 socket 通道之间直接传输数据**，不过 socket 通道实现WritableByteChannel 和 ReadableByteChannel接口，因此文件的内容可以用 <span class="title">transferTo</span><span class="params">( )</span>方法传输给一个 socket 通道，或者也可以用 <span class="title">transferFrom</span><span class="params">( )</span>方法将数据从一个 socket通道直接读取到一个文件中。</div><div class="line">3. **直接的通道传输不会更新与某个 FileChannel 关联的 position 值。**</div><div class="line">4.  + 对于传输数据来源是一个文件的<span class="title">transferTo</span><span class="params">()</span>方法，如果position+count的值大于文件的size值，传输会在文件尾的位置终止。</div><div class="line">    + 假如传输的目的地是一个非阻塞模式的socket通道，那么当发送队列（sendqueue）满了之后传输就可能终止，并且如果输出队列（output queue）已满的话可能不会发送任何数据。</div><div class="line">    + 类似地，对于 <span class="title">transferFrom</span><span class="params">( )</span>方法：如果来源 src是另外一个FileChannel并且已经到达文件尾，那么传输将提早终止；如果来源 src 是一个非阻塞 socket通道，只有当前处于队列中的数据才会被传输（可能没有数据）。**由于网络数据传输的非确定性，阻塞模式的socket 也可能会执行部分传输，这取决于操作系统。许多通道实现都是提供它们当前队列中已有的数据而不是等待您请求的全部数据都准备好。**</div><div class="line"># Socket通道</div><div class="line">![socket-channel-class][4]</div><div class="line"></div><div class="line">1. 使用Channel没有为每个 socket连接使用一个线程的必要了，也避免了管理大量线程所需的上下文交换总开销。</div><div class="line">2. 请注意 DatagramChannel 和SocketChannel实现定义读和写功能的接口而ServerSocketChannel不实现。ServerSocketChannel 负责监听传入的连接和创建新的 SocketChannel 对象，它本身从不传输数据。</div><div class="line">3. **虽然每个 socket 通道（在 java.nio.channels 包中）都有一个关联的 java.net socket 对象，却并非所有的 socket 都有一个关联的通道。**如果您用传统方式（直接实例化）创建了一个Socket 对象，它就不会有关联的 SocketChannel并且它的 <span class="title">getChannel</span><span class="params">( )</span>方法将总是返回 <span class="keyword">null</span>。</div><div class="line">## 非阻塞模式</div><div class="line"> Socket 通道可以工作在阻塞和非阻塞模式下，并且可以在运行过程中动态切换。</div><div class="line">SelectableChannel:</div><div class="line">```java</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class SelectableChannel</div><div class="line">extends AbstractChannel</div><div class="line">implements Channel</div><div class="line">&#123;</div><div class="line"><span class="comment">// This is a partial API listing</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">configureBlocking</span> <span class="params">(<span class="keyword">boolean</span> block)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isBlocking</span><span class="params">( )</span></span>;<span class="number">99</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">blockingLock</span><span class="params">( )</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>要把一个 socket 通道置于非阻塞模式，我们要依靠所有 socket 通道类的公有超级类：SelectableChannel。<br> <strong>非阻塞 I/O 和可选择性是紧密相连的，那也正是管理阻塞模式的 API 代码要在SelectableChannel 超级类中定义的原因。</strong></p>
</li>
<li><p>blockingLock( )<br> 该方法会返回一个非透明的对象引用。返回的对象是通道实现修改阻塞模式时内部使用的。只有拥有此对象的锁的线程才能更改通道的阻塞模式。</p>
<h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSocketChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ServerSocket <span class="title">socket</span><span class="params">( )</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketChannel <span class="title">accept</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">( )</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>用静态的 open( )工厂方法创建一个新的 ServerSocketChannel 对象，将会返回与一个未绑定的java.net.ServerSocket 关联的通道。该对等 ServerSocket可以通过在返回的ServerSocketChannel上调用socket()方法来获取。作为ServerSocketChannel 的对等体被创建的 ServerSocket对象依赖通道实现。这些socket关联的SocketImpl能识别通道。通道不能被封装在随意的 socket 对象外面</p>
</li>
<li><p>accept</p>
<ul>
<li><strong>如果您选择在 ServerSocket 上调用 accept( )方法</strong><br>  那么它会同任何其他的 ServerSocket 表现一样的行为：总是阻塞并返回一个 java.net.Socket 对象。</li>
<li>如果您选择在 ServerSocketChannel 上调用 accept( )<br>  方法则会返回 SocketChannel 类型的对象，返回的对象能够在非阻塞模式下运行。</li>
<li>如果在非阻塞模式下的ServerSocketChannel上调用<br>  当没有传入连接在等待时， ServerSocketChannel.accept( )会立即返回 null。<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2>SocketChannel原型：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></div><div class="line"><span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// This is a partial API listing</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span> <span class="params">(InetSocketAddress remote)</span></div><div class="line"><span class="keyword">throws</span> IOException</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Socket <span class="title">socket</span><span class="params">( )</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">connect</span> <span class="params">(SocketAddress remote)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;<span class="number">103</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnectionPending</span><span class="params">( )</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( )</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">validOps</span><span class="params">( )</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>connect()</p>
<ul>
<li>阻塞模式下：<br>  在Socket对象上调用和通过在阻塞模式的SocketChannel上调用时相同：线程在连接建立好或超时过期之前都将保持阻塞。</li>
<li>非阻塞模式的SocketChannel上调用<br>  线程不阻塞，如果返回值是true，说明连接立即建立了（这可能是本地环回连接）；如果连接不能立即建立， connect( )方法会返回 false 且并发地继续连接建立过程。</li>
</ul>
</li>
<li><strong>在 SocketChannel 上并没有一种connect()方法可以让您指定超时（timeout）值，编程时一般使用非阻塞模式的SocketChannel.connect()建立异步连接。</strong></li>
<li>isConnectPending()</li>
<li><strong>finishConnect()</strong><ul>
<li>connect( )方法尚未被调用。那么将产生 NoConnectionPendingException 异常。</li>
<li>连接建立过程正在进行，尚未完成。那么什么都不会发生， finishConnect( )方法会立即返回false 值。</li>
<li>在非阻塞模式下调用 connect()方法之后，SocketChannel又被切换回了阻塞模式。那么如果有必要的话，调用线程会阻塞直到连接建立完成， finishConnect( )方法接着就会返回 true值。</li>
<li>在初次调用 connect( )或最后一次调用finishConnect()之后，连接建立过程已经完成。那么SocketChannel对象的内部状态将被更新到已连接状态， finishConnect( )方法会返回 true值，然后 SocketChannel对象就可以被用来传输数据了。</li>
<li>连接已经建立。那么什么都不会发生，finishConnect()方法会返回true值。假如某个SocketChannel上当前正由一个并发连接， isConnectPending( )方法就会返回 true 值。</li>
</ul>
</li>
<li>isConnected( )<br> 不阻塞</li>
<li>当通道处于中间的连接等待（connection-pending）状态时，您只可以调用 finishConnect( )、isConnectPending( )或isConnected( )方法。</li>
<li><strong>如果尝试异步连接失败，那么下次调用finishConnect()方法会产生一个适当的经检查的异常以指出问题的性质。通道然后就会被关闭并将不能被连接或再次使用.</strong></li>
<li><strong>connect( )和 finishConnect()方法是互相同步的，并且只要其中一个操作正在进行，任何读或写的方法调用都会阻塞,即使是在非阻塞模式下。如果此情形下您有疑问或不能承受一个读或写操作在某个通道上阻塞，请用isConnected()方法测试一下连接状态。</strong><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2>TCP/IP 这样面向流的的协议为了在包导向的互联网基础设施上维护流语义必然会产生巨大的开销，并且流隐喻不能适用所有的情形。<strong>数据报的吞吐量要比流协议高很多， 并且数据报可以做很多流无法完成的事情。</strong></li>
</ol>
<p>DatagramChannel的原型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DatagramChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></div><div class="line"><span class="keyword">implements</span> <span class="title">ByteChannel</span>, <span class="title">ScatteringByteChannel</span>, <span class="title">GatheringByteChannel</span></div><div class="line">&#123;</div><div class="line"><span class="comment">// This is a partial API listing</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DatagramChannel <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramSocket <span class="title">socket</span><span class="params">( )</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">connect</span> <span class="params">(SocketAddress remote)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">( )</span></span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> DatagramChannel <span class="title">disconnect</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SocketAddress <span class="title">receive</span> <span class="params">(ByteBuffer dst)</span></span></div><div class="line"><span class="keyword">throws</span> IOException;<span class="number">107</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">send</span> <span class="params">(ByteBuffer src, SocketAddress target)</span></span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span> <span class="params">(ByteBuffer dst)</span> <span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">read</span> <span class="params">(ByteBuffer [] dsts, <span class="keyword">int</span> offset,</span></span></div><div class="line"><span class="keyword">int</span> length)</div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">write</span> <span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">write</span><span class="params">(ByteBuffer[] srcs, <span class="keyword">int</span> offset,</span></span></div><div class="line"><span class="keyword">int</span> length)</div><div class="line"><span class="keyword">throws</span> IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>DatagramChannel 对象既可以充当服务器（监听者）也可以充当客户端（发送者）。<ul>
<li>如果您希望新创建的通道负责监听，那么通道必须首先被绑定到一个端口或地址/端口组合上。</li>
<li><strong>不论通道是否绑定，所有发送的包都含有 DatagramChannel 的源地址（带端口号）。</strong></li>
<li><strong>未绑定的 DatagramChannel可以接收发送给它的端口的包，通常是来回应该通道之前发出的一个包。通道绑定了端口或者发送了数据包之后就有了相应端口，否则没有端口，也就不能接收数据。</strong></li>
</ul>
</li>
<li>与面向流的的 socket 不同， DatagramChannel 可以发送单独的数据报给不同的目的地址。同样， DatagramChannel 对象也可以接收来自任意地址的数据包。每个到达的数据报都含有关于它来自何处的信息（源地址）。</li>
<li>receive()<br> receive( )方法将下次将传入的数据报的数据净荷复制到预备好的ByteBuffer中并返回一个SocketAddress对象以指出数据来源。<ul>
<li>如果通道处于阻塞模式， receive( )可能无限期地休眠直到有包到达。</li>
<li>如果是非阻塞模式，当没有可接收的包时则会返回 null。</li>
<li><strong>假如您提供的 ByteBuffer 没有足够的剩余空间来存放您正在接收的数据包，没有被填充的字节都会被悄悄地丢弃</strong></li>
</ul>
</li>
<li>send()<br> 如果 DatagramChannel 对象处于阻塞模式，调用线程可能会休眠直到数据报被加入传输队列。<br> <strong>发送数据报是一个全有或全无（all-or-nothing）的行为。</strong><ul>
<li><strong>如果通道是非阻塞的，返回值要么是字节缓冲区的字节数，要么是“0”。</strong></li>
<li>如果传输队列没有足够空间来承载整个数据报，那么什么内容都不会被发送。</li>
</ul>
</li>
<li>connect()语义<ul>
<li>将 DatagramChannel 置于已连接的状态可以使除了它所“连接”到的地址之外的任何其他源地址的数据报被忽略。这是很有帮助的，因为不想要的包都已经被网络层丢弃了，从而避免了使用代码来接收、检查然后丢弃包的麻烦。</li>
<li>当 DatagramChannel 已连接时，使用同样的令牌，您不可以发送包到除了指定给connect()方法的目的地址以外的任何其他地址。试图一定要这样做的话会导致一个 <strong>SecurityException 异常</strong>。</li>
<li>已连接通道会发挥作用的使用场景之一是一个客户端/服务器模式、使用 UDP 通讯协议的实时游戏。每个客户端都只和同一台服务器进行会话而希望忽视任何其他来源地数据包。将客户端的DatagramChannel 实例置于已连接状态可以减少按包计算的总开销（因为不需要对每个包进行安全检查）和剔除来自欺骗玩家的假包。服务器可能也想要这样做，不过需要每个客户端都有一个DatagramChannel 对象。</li>
<li><strong>DatagramChannel 没有单独的 finishConnect( )方法。我们可以使用isConnected()方法来测试一个数据报通道的连<br>接状态。</strong></li>
<li><strong>DatagramChannel 对象可以任意次数地进行连接或断开连接。每次连接都可以到一个不同的远程地址。<br>  调用 disconnect( )方法可以配置通道，以便它能再次接收来自安全管理器（如果已安装）所允许的任意远程地址的数据或发送数据到这些地址上。</strong></li>
<li>当一个 DatagramChannel 处于已连接状态时，发送数据将不用提供目的地址而且接收时的源地址也是已知的。这意味着DatagramChannel已连接时可以使用常规的 read( )和 write( )方法，包括scatter/gather形式的读写来组合或分拆包的数据。</li>
<li>read( )方法返回读取字节的数量，如果通道处于非阻塞模式的话这个返回值可能是“0”。write( )方法的返回值同 send( )方法一致：<strong>要么返回您的缓冲区中的字节数量，要么返回“0”</strong>（如果由于通道处于非阻塞模式而导致数据报不能被发送）。<strong>当通道不是已连接状态时调用 read( )或write( )方法，都将产生 NotYetConnectedException 异常。</strong><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1>Pipe 类创建一对提供环回机制的 Channel 对象。这两个通道的远端是连接起来的，以便任何写在 SinkChannel 对象上的数据都能出现在 SourceChannel 对象上。</li>
</ul>
</li>
</ol>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/pipe-class.png" alt="pipe-class"></p>
<p>Pipe原型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> java.nio.channels;</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pipe</span></span></div><div class="line">&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pipe <span class="title">open</span><span class="params">( )</span> <span class="keyword">throws</span> IOException</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> SourceChannel <span class="title">source</span><span class="params">( )</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SinkChannel <span class="title">sink</span><span class="params">( )</span></span>;<span class="number">119</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceChannel</span></span></div><div class="line"><span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></div><div class="line"><span class="keyword">implements</span> <span class="title">ReadableByteChannel</span>, <span class="title">ScatteringByteChannel</span></div><div class="line"><span class="title">public</span> <span class="title">static</span> <span class="title">abstract</span> <span class="title">class</span> <span class="title">SinkChannel</span></div><div class="line"><span class="keyword">extends</span> <span class="title">AbstractSelectableChannel</span></div><div class="line"><span class="keyword">implements</span> <span class="title">WritableByteChannel</span>, <span class="title">GatheringByteChannel</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>Pipe.SourceChannel（管道负责读的一端）， Pipe.SinkChannel（管道负责写的一端）。<br> 这两个通道实例是在 Pipe 对象创建的同时被创建的，可以通过在 Pipe 对象上分别调用 source( )和 sink( )方法来取回。</li>
<li><strong>SinkChannel 和 SourceChannel 都由 AbstractSelectableChannel 引申而来（所以也是从 SelectableChannel 引申而来），这意味着 pipe 通道可以同选择器一起使用.</strong></li>
<li><strong>管道可以被用来仅在同一个 Java虚拟机内部传输数据（不能在外部）。</strong>虽然有更加有效率的方式来在线程之间传输数据，<strong>但是使用管道的好处在于封装性。</strong></li>
<li><strong>生产者线程和用户线程都能被写道通用的Channel API中。根据给定的通道类型，相同的代码可以被用来写数据到一个文件、socket或管道。选择器可以被用来检查管道上的数据可用性，如同在socket通道上使用那样地简单。这样就可以允许单个用户线程使用一个Selector来从多个通道有效地收集数据，并可任意结合网络连接或本地工作线程使用。因此，这些对于可伸缩性、冗余度以及可复用性来说无疑都是意义重大的。</strong></li>
<li><strong>管道所能承载的数据量是依赖实现的（implementation-dependent）。唯一可保证的是写到SinkChannel中的字节都能按照同样的顺序在 SourceChannel 上重现。</strong></li>
</ol>
<h1 id="通道工具类"><a href="#通道工具类" class="headerlink" title="通道工具类"></a>通道工具类</h1><p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/channel-util-table.png" alt="channel-util-table"></p>
<p><strong>这些方法返回的包封 Channel 对象可能会也可能不会实现 InterruptibleChannel 接口，它们也可能不是从 SelectableChannel 引申而来。因此，可能无法将这些包封通道同 java.nio.channels包中定义的其他通道类型交换使用。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文内容主要摘录自：《JAVA NIO》。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Channel的类图如下：&lt;br&gt;&lt;img src=&quot;http://oqxil93b6.bkt.clouddn.com/images/IO/Channel-class.png&quot; al
    
    </summary>
    
      <category term="io" scheme="http://YDDMAX.github.io/categories/io/"/>
    
    
      <category term="java" scheme="http://YDDMAX.github.io/tags/java/"/>
    
      <category term="io" scheme="http://YDDMAX.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Zero Copy I: User-Mode Perspective</title>
    <link href="http://YDDMAX.github.io/2017/06/14/Zero-Copy-I-User-Mode-Perspective/"/>
    <id>http://YDDMAX.github.io/2017/06/14/Zero-Copy-I-User-Mode-Perspective/</id>
    <published>2017-06-14T14:57:47.000Z</published>
    <updated>2017-06-14T14:58:54.125Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://www.linuxjournal.com/article/6345" target="_blank" rel="external">Zero Copy I: User-Mode Perspective</a></p>
<p>Explaining what is zero-copy functionality for Linux, why it’s useful and where it needs work.<br>By now almost everyone has heard of so-called zero-copy functionality under Linux, but I often run into people who don’t have a full understanding of the subject. Because of this, I decided to write a few articles that dig into the matter a bit deeper, in the hope of unraveling this useful feature. In this article, we take a look at zero copy from a user-mode application point of view, so gory kernel-level details are omitted intentionally.</p>
<p># </p>
<h1 id="What-Is-Zero-Copy"><a href="#What-Is-Zero-Copy" class="headerlink" title="What Is Zero-Copy?"></a>What Is Zero-Copy?</h1><h2 id="普通的"><a href="#普通的" class="headerlink" title="普通的"></a>普通的</h2><p>To better understand the solution to a problem, we first need to understand the problem itself. Let’s look at what is involved in the simple procedure of a network server d?mon serving data stored in a file to a client over the network. Here’s some sample code:</p>
<p><code>read(file, tmp_buf, len);</code><br><code>write(socket, tmp_buf, len);</code></p>
<p>Looks simple enough; you would think there is not much overhead with only those two system calls. In reality, this couldn’t be further from the truth. Behind those two calls, <strong>the data has been copied at least four times, and almost as many user/kernel context switches have been performed.</strong>(Actually this process is much more complicated, but I wanted to keep it simple). To get a better idea of the process involved, take a look at Figure 1. The top side shows context switches, and the bottom side shows copy operations.</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/step1-zero-copy-1.jpg" alt="zero-copy-1"><br>Figure 1. Copying in Two Sample System Calls</p>
<ol>
<li><p>Step one: the read system call causes a context switch from user mode to kernel mode. The first copy is performed by the DMA engine, which reads file contents from the disk and stores them into a kernel address space buffer.</p>
</li>
<li><p>Step two: data is copied from the kernel buffer into the user buffer, and the read system call returns. The return from the call caused a context switch from kernel back to user mode. Now the data is stored in the user address space buffer, and it can begin its way down again.</p>
</li>
<li><p>Step three: the write system call causes a context switch from user mode to kernel mode. A third copy is performed to put the data into a kernel address space buffer again. This time, though, the data is put into a different buffer, a buffer that is associated with sockets specifically.</p>
</li>
<li><p>Step four: the write system call returns, creating our fourth context switch. Independently and asynchronously, a fourth copy happens as the DMA engine passes the data from the kernel buffer to the protocol engine. You are probably asking yourself, “What do you mean independently and asynchronously? Wasn’t the data transmitted before the call returned?” Call return, in fact, doesn’t guarantee transmission; it doesn’t even guarantee the start of the transmission.<strong>It simply means the Ethernet driver had free descriptors in its queue and has accepted our data for transmission. There could be numerous packets queued before ours. Unless the driver/hardware implements priority rings or queues, data is transmitted on a first-in-first-out basis. (The forked DMA copy in Figure 1 illustrates the fact that the last copy can be delayed).</strong></p>
</li>
</ol>
<p>As you can see, a lot of data duplication is not really necessary to hold things up. Some of the duplication could be eliminated to decrease overhead and increase performance. As a driver developer, I work with hardware that has some pretty advanced features. Some hardware can bypass the main memory altogether and transmit data directly to another device. This feature eliminates a copy in the system memory and is a nice thing to have, but not all hardware supports it. There is also the issue of the data from the disk having to be repackaged for the network, which introduces some complications. To eliminate overhead, we could start by eliminating some of the copying between the kernel and user buffers.</p>
<h2 id="引入mmap"><a href="#引入mmap" class="headerlink" title="引入mmap"></a>引入mmap</h2><p>One way to eliminate a copy is to skip calling read and instead call mmap. For example:</p>
<p><code>tmp_buf = mmap(file, len);</code><br><code>write(socket, tmp_buf, len);</code></p>
<p>To get a better idea of the process involved, take a look at Figure 2. Context switches remain the same.</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/step-zero-copy-2.jpg" alt="zero-copy-step2"><br>Figure 2. Calling mmap</p>
<ol>
<li><p>Step one: the mmap system call causes the file contents to be copied into a kernel buffer by the DMA engine. The buffer is shared then with the user process, without any copy being performed between the kernel and user memory spaces.</p>
</li>
<li><p>Step two: the write system call causes the kernel to copy the data from the original kernel buffers into the kernel buffers associated with sockets.</p>
</li>
<li><p>Step three: the third copy happens as the DMA engine passes the data from the kernel socket buffers to the protocol engine.</p>
</li>
</ol>
<p><strong>By using mmap instead of read, we’ve cut in half the amount of data the kernel has to copy(减小了一次copy,上下文切换次数没有变).</strong> this yields reasonably good results when a lot of data is being transmitted. However, this improvement doesn’t come without a price; <strong>there are hidden pitfalls when using the mmap+write method. You will fall into one of them when you memory map a file and then call write while another process truncates the same file.</strong> Your write system call will be interrupted by the bus error signal SIGBUS, because you performed a bad memory access. The default behavior for that signal is to kill the process and dump core—not the most desirable operation for a network server. There are two ways to get around this problem.</p>
<ol>
<li><p>The first way is to install a signal handler for the SIGBUS signal, and then simply call return in the handler. By doing this the write system call returns with the number of bytes it wrote before it got interrupted and the errno set to success. Let me point out that this would be a bad solution, one that treats the symptoms and not the cause of the problem. Because SIGBUS signals that something has gone seriously wrong with the process, I would discourage using this as a solution.</p>
</li>
<li><p>The second solution involves <strong>file leasing</strong>  (which is called “opportunistic locking” in Microsoft Windows) from the kernel. This is the correct way to fix this problem. By using leasing on the file descriptor, you take a lease with the kernel on a particular file. You then can request a read/write lease from the kernel. When another process tries to truncate the file you are transmitting, the kernel sends you a real-time signal, the RT_SIGNAL_LEASE signal. It tells you the kernel is breaking your write or read lease on that file. Your write call is interrupted before your program accesses an invalid address and gets killed by the SIGBUS signal. The return value of the write call is the number of bytes written before the interruption, and the errno will be set to success. Here is some sample code that shows how to get a lease from the kernel:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(fcntl(fd, F_SETSIG, RT_SIGNAL_LEASE) == <span class="number">-1</span>) &#123;</div><div class="line">    perror(<span class="string">"kernel lease set signal"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK */</span></div><div class="line"><span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_type))&#123;</div><div class="line">    perror(<span class="string">"kernel lease set type"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>You should get your lease before mmaping the file, and break your lease after you are done. This is achieved by calling fcntl F_SETLEASE with the lease type of F_UNLCK.</p>
<h2 id="引入Sendfile"><a href="#引入Sendfile" class="headerlink" title="引入Sendfile"></a>引入Sendfile</h2><p><strong>In kernel version 2.1, the sendfile system call was introduced to simplify the transmission of data over the network and between two local files.</strong><br><strong>Introduction of sendfile not only reduces data copying, it also reduces context switches. Use it like this:</strong></p>
<p><code>sendfile(socket, file, len);</code></p>
<p>To get a better idea of the process involved, take a look at Figure 3.</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/step-zero-copy-3.jpg" alt="step-zero-copy-3"><br>Figure 3. Replacing Read and Write with Sendfile</p>
<ol>
<li><p>Step one: the sendfile system call causes the file contents to be copied into a kernel buffer by the DMA engine. Then the data is copied by the kernel into the kernel buffer associated with sockets.</p>
</li>
<li><p>Step two: the third copy happens as the DMA engine passes the data from the kernel socket buffers to the protocol engine.</p>
</li>
</ol>
<p>You are probably wondering what happens if another process truncates the file we are transmitting with the sendfile system call. If we don’t register any signal handlers, the sendfile call simply returns with the number of bytes it transferred before it got interrupted, and the errno will be set to success.</p>
<p>If we get a lease from the kernel on the file before we call sendfile, however, the behavior and the return status are exactly the same. We also get the RT_SIGNAL_LEASE signal before the sendfile call returns.</p>
<p><strong>So far, we have been able to avoid having the kernel make several copies, but we are still left with one copy.</strong> Can that be avoided too? Absolutely, with a little help from the hardware. <strong>To eliminate all the data duplication done by the kernel, we need a network interface that supports gather operations. This simply means that data awaiting transmission doesn’t need to be in consecutive memory; it can be scattered through various memory locations.</strong> In kernel version 2.4, the socket buffer descriptor was modified to accommodate those requirements—what is known as zero copy under Linux. This approach not only reduces multiple context switches, it also eliminates data duplication done by the processor. For user-level applications nothing has changed, so the code still looks like this:</p>
<p><code>sendfile(socket, file, len);</code><br>To get a better idea of the process involved, take a look at Figure 4.<br><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/step-zero-copy-4.jpg" alt="zero-copy-4"></p>
<p>Figure 4. Hardware that supports gather can assemble data from multiple memory locations, eliminating another copy.</p>
<ol>
<li><p>Step one: the sendfile system call causes the file contents to be copied into a kernel buffer by the DMA engine.</p>
</li>
<li><p>Step two: <strong>no data is copied into the socket buffer. Instead, only descriptors with information about the whereabouts and length of the data are appended to the socket buffer. The DMA engine passes data directly from the kernel buffer to the protocol engine, thus eliminating the remaining final copy.</strong></p>
</li>
</ol>
<p><strong>Because data still is actually copied from the disk to the memory and from the memory to the wire, some might argue this is not a true zero copy.</strong><br><strong>This is zero copy from the operating system standpoint, though, because the data is not duplicated between kernel buffers.</strong><br>When using zero copy, other performance benefits can be had besides <strong>copy avoidance</strong>, such as <strong>fewer context switches</strong>, <strong>less CPU data cache pollution</strong> and <strong>no CPU checksum calculations</strong>.</p>
<h1 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h1><p>Now that we know what zero copy is, let’s put theory into practice and write some code. You can download the full source code from <a href="www.xalien.org/articles/source/sfl-src.tgz">www.xalien.org/articles/source/sfl-src.tgz</a>. To unpack the source code, type <code>tar -zxvf sfl-src.tgz at the prompt</code>. To compile the code and create the random data file data.bin, run make.</p>
<p>Looking at the code starting with header files:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* sfl.c sendfile example program</span></div><div class="line">Dragan Stancevic &lt;</div><div class="line">header name                 function / variable</div><div class="line">-------------------------------------------------*/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;          /* printf, perror */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;          /* open */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;         /* close */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;          /* errno */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;         /* memset */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;     /* socket */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;     /* sockaddr_in */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;   /* sendfile */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;      /* inet_addr */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFF_SIZE (10*1024) <span class="comment">/* size of the tmp buffer */</span></span></div></pre></td></tr></table></figure></p>
<p>Besides the regular <sys socket.h=""> and <netinet in.h=""> required for basic socket operation, we need a prototype definition of the sendfile system call. This can be found in the <sys sendfile.h=""> server flag:</sys></netinet></sys></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/* are we sending or receiving */</div><div class="line">if(argv[1][0] == 's') is_server++;</div><div class="line">/* open descriptors */</div><div class="line">sd = socket(PF_INET, SOCK_STREAM, 0);</div><div class="line">if(is_server) fd = open("data.bin", O_RDONLY);</div><div class="line">The same program can act as either a server/sender or a client/receiver. We have to check one of the command-prompt parameters, and then set the flag is_server to run in sender mode. We also open a stream socket of the INET protocol family. As part of running in server mode we need some type of data to transmit to a client, so we open our data file. We are using the system call sendfile to transmit data, so we don't have to read the actual contents of the file and store it in our program memory buffer. Here's the server address:</div><div class="line">/* clear the memory */</div><div class="line">memset(&amp;sa, 0, sizeof(struct sockaddr_in));</div><div class="line">/* initialize structure */</div><div class="line">sa.sin_family = PF_INET;</div><div class="line">sa.sin_port = htons(1033);</div><div class="line">sa.sin_addr.s_addr = inet_addr(argv[2]);</div><div class="line">We clear the server address structure and assign the protocol family, port and IP address of the server. The address of the server is passed as a command-line parameter. The port number is hard coded to unassigned port 1033. This port number was chosen because it is above the port range requiring root access to the system.</div><div class="line">Here is the server execution branch:</div><div class="line"></div><div class="line">if(is_server)&#123;</div><div class="line">    int client; /* new client socket */</div><div class="line">    printf("Server binding to [%s]\n", argv[2]);</div><div class="line">    if(bind(sd, (struct sockaddr *)&amp;sa,</div><div class="line">                      sizeof(sa)) &lt; 0)&#123;</div><div class="line">        perror("bind");</div><div class="line">        exit(errno);</div><div class="line">    &#125;</div><div class="line">As a server, we need to assign an address to our socket descriptor. This is achieved by the system call bind, which assigns the socket descriptor (sd) a server address (sa):</div><div class="line"></div><div class="line">if(listen(sd,1) &lt; 0)&#123;</div><div class="line">    perror("listen");</div><div class="line">    exit(errno);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Because we are using a stream socket, we have to advertise our willingness to accept incoming connections and set the connection queue size. I’ve set the backlog queue to 1, but it is common to set the backlog a bit higher for established connections waiting to be accepted. In older versions of the kernel, the backlog queue was used to prevent syn flood attacks. Because the system call listen changed to set parameters for only established connections, the backlog queue feature has been deprecated for this call. The kernel parameter tcp_max_syn_backlog has taken over the role of protecting the system from syn flood attacks:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((client = accept(sd, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(<span class="string">"accept"</span>);</div><div class="line">    <span class="built_in">exit</span>(errno);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The system call accept creates a new connected socket from the first connection request on the pending connections queue. The return value from the call is a descriptor for a newly created connection; the socket is now ready for read, write or poll/select system calls:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>((cnt = sendfile(client,fd,&amp;off,</div><div class="line">                          BUFF_SIZE)) &lt; <span class="number">0</span>)&#123;</div><div class="line">    perror(<span class="string">"sendfile"</span>);</div><div class="line">    <span class="built_in">exit</span>(errno);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"Server sent %d bytes.\n"</span>, cnt);</div><div class="line">close(client);</div></pre></td></tr></table></figure></p>
<p>A connection is established on the client socket descriptor, so we can start transmitting data to the remote system. We do this by calling the sendfile system call, which is prototyped under Linux in the following manner:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> ssize_t</span></div><div class="line"><span class="title">sendfile</span> <span class="params">(<span class="keyword">int</span> __out_fd, <span class="keyword">int</span> __in_fd, <span class="keyword">off_t</span> *offset,</span></div><div class="line">          <span class="keyword">size_t</span> __count) __THROW;</div></pre></td></tr></table></figure></p>
<p>The first two parameters are file descriptors. The third parameter points to an offset from which sendfile should start sending data. The fourth parameter is the number of bytes we want to transmit. In order for the sendfile transmit to use zero-copy functionality, you need memory gather operation support from your networking card. You also need checksum capabilities for protocols that implement checksums, such as TCP or UDP. If your NIC is outdated and doesn’t support those features, you still can use sendfile to transmit files. The difference is the kernel will merge the buffers before transmitting them.</p>
<h1 id="others"><a href="#others" class="headerlink" title="others"></a>others</h1><h2 id="Portability-Issues"><a href="#Portability-Issues" class="headerlink" title="Portability Issues"></a>Portability Issues</h2><ol>
<li><p>One of the problems with the sendfile system call, in general, is the lack of a standard implementation, as there is for the open system call.<strong>Sendfile implementations in Linux, Solaris or HP-UX are quite different.</strong>  This poses a problem for developers who wish to use zero copy in their network data transmission code.</p>
<ul>
<li><strong>One of the implementation differences is Linux provides a sendfile that defines an interface for transmitting data between two file descriptors (file-to-file) and (file-to-socket).</strong> </li>
<li><strong>HP-UX and Solaris, on the other hand, can be used only for file-to-socket submissions.</strong></li>
</ul>
</li>
<li><p>The second difference is Linux doesn’t implement <strong>vectored transfers</strong>. Solaris sendfile and HP-UX sendfile have extra parameters that eliminate overhead associated with prepending headers to the data being transmitted.</p>
<h2 id="Looking-Ahead"><a href="#Looking-Ahead" class="headerlink" title="Looking Ahead"></a>Looking Ahead</h2><p>The implementation of zero copy under Linux is far from finished and is likely to change in the near future. More functionality should be added. For example, <strong>the sendfile call doesn’t support vectored transfers</strong>, and servers such as Samba and Apache have to use multiple sendfile calls with the TCP_CORK flag set. This flag tells the system more data is coming through in the next sendfile calls. TCP_CORK also is incompatible with TCP_NODELAY and is used when we want to prepend or append headers to the data. This is a perfect example of where a vectored call would eliminate the need for multiple sendfile calls and delays mandated by the current implementation.</p>
</li>
</ol>
<p><strong>One rather unpleasant limitation in the current sendfile is it cannot be used when transferring files greater than 2GB.</strong> Files of such size are not all that uncommon today, and it’s rather disappointing having to duplicate all that data on its way out. Because both sendfile and mmap methods are unusable in this case, a sendfile64 would be really handy in a future kernel version.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Despite some drawbacks, zero-copy sendfile is a useful feature, and I hope you have found this article informative enough to start using it in your programs. If you have a more in-depth interest in the subject, keep an eye out for my second article, titled “Zero Copy II: Kernel Perspective”, where I will dig a bit more into the kernel internals of zero copy.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://www.linuxjournal.com/article/6345&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Zero Copy I: User-Mode Perspective&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Explai
    
    </summary>
    
      <category term="io" scheme="http://YDDMAX.github.io/categories/io/"/>
    
    
      <category term="io" scheme="http://YDDMAX.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>FileChannel</title>
    <link href="http://YDDMAX.github.io/2017/06/12/FileChannel/"/>
    <id>http://YDDMAX.github.io/2017/06/12/FileChannel/</id>
    <published>2017-06-12T06:21:58.000Z</published>
    <updated>2017-06-11T23:33:54.879Z</updated>
    
    <content type="html"><![CDATA[<p>FileChannel主要进行文件IO的操作，下面主要分析write()的整个过程，read()和write()是相同的。</p>
<h1 id="概要"><a href="#概要" class="headerlink" title="概要　"></a>概要　</h1><p>write()/read()时:</p>
<ul>
<li>如果传入的是DirectBuffer，则不需要进行数据复制，最后通过write系统调用完成IO。</li>
<li>如果传入的是非DirectBuffer，则先从本线程的DirectBuffer池中得到一个满足（size能容纳所有数据）的Buffer,之后进行数据复制，并使用DirectBuffer参与write系统调用完成IO。</li>
</ul>
<p><strong>对于第二种情况，数据复制会引起效率。如果业务代码再不重复利用所传入的非DirectBuffer，则会增加GC频率。<br>第二种情况，线程里有一个DirectBuffer池，使得DirectBuffer可以重复利用。这样不仅可以减小DirectBuffer的新建和释放开销，而且可以减小GC频率。这给我们以借鉴，我们在编写业务代码时页应该这样处理。</strong></p>
<p>下面分析具体的源码。</p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>sun.nio.ch.FileChannelImpl.write()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (!writable)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NonWritableChannelException();</div><div class="line">    <span class="keyword">synchronized</span> (positionLock) &#123;</div><div class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</div><div class="line">        Object traceContext = IoTrace.fileWriteBegin(path);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            begin();</div><div class="line">            ti = threads.add();</div><div class="line">            <span class="keyword">if</span> (!isOpen())</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="comment">//这里写</span></div><div class="line">                n = IOUtil.write(fd, src, -<span class="number">1</span>, nd);</div><div class="line">            &#125; <span class="keyword">while</span> ((n == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</div><div class="line">            <span class="keyword">return</span> IOStatus.normalize(n);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            threads.remove(ti);</div><div class="line">            end(n &gt; <span class="number">0</span>);</div><div class="line">            IoTrace.fileWriteEnd(traceContext, n &gt; <span class="number">0</span> ? n : <span class="number">0</span>);</div><div class="line">            <span class="keyword">assert</span> IOStatus.check(n);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>sun.nio.ch.IOUtil.write()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, ByteBuffer src, <span class="keyword">long</span> position,</span></span></div><div class="line">                   NativeDispatcher nd)</div><div class="line">      <span class="keyword">throws</span> IOException</div><div class="line">  &#123;</div><div class="line">      <span class="comment">//如果是DirectBuffer</span></div><div class="line">      <span class="keyword">if</span> (src <span class="keyword">instanceof</span> DirectBuffer)</div><div class="line">          <span class="keyword">return</span> writeFromNativeBuffer(fd, src, position, nd);</div><div class="line"></div><div class="line">      <span class="comment">// Substitute a native buffer</span></div><div class="line">      <span class="keyword">int</span> pos = src.position();</div><div class="line">      <span class="keyword">int</span> lim = src.limit();</div><div class="line">      <span class="keyword">assert</span> (pos &lt;= lim);</div><div class="line">      <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</div><div class="line">      <span class="comment">//从本线程所缓存的临时DirectBuffer池中得到一个size满足的Buffer（如果没有符合的，new一个）</span></div><div class="line">      ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">//数据copy</span></div><div class="line">          bb.put(src);</div><div class="line">          bb.flip();</div><div class="line">          <span class="comment">// Do not update src until we see how many bytes were written</span></div><div class="line">          src.position(pos);</div><div class="line">          <span class="comment">//真正的写</span></div><div class="line">          <span class="keyword">int</span> n = writeFromNativeBuffer(fd, bb, position, nd);</div><div class="line">          <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="comment">// now update src</span></div><div class="line">              src.position(pos + n);</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> n;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          <span class="comment">//将本次使用的DirectBuffer重新还给DirectBuffer池</span></div><div class="line">          Util.offerFirstTemporaryDirectBuffer(bb);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>接上面，sun.nio.ch.Util.getTemporaryDirectBuffer()。<br><strong>下面代码说明了每个线程维持了一个DirectBuffer池，当使用的是Heap类型的Buffer进行IO时，需要先从池中得到一个DirectBuffer,之后还有进行数据复制等，并使用DirectBuffer参与系统调用完成IO。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a temporary buffer of at least the given size</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> ByteBuffer <span class="title">getTemporaryDirectBuffer</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    BufferCache cache = bufferCache.get();</div><div class="line">    ByteBuffer buf = cache.get(size);</div><div class="line">    <span class="keyword">if</span> (buf != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> buf;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// No suitable buffer in the cache so we need to allocate a new</span></div><div class="line">        <span class="comment">// one. To avoid the cache growing then we remove the first</span></div><div class="line">        <span class="comment">// buffer from the cache and free it.</span></div><div class="line">        <span class="keyword">if</span> (!cache.isEmpty()) &#123;</div><div class="line">            buf = cache.removeFirst();</div><div class="line">            free(buf);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ByteBuffer.allocateDirect(size);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>sun.nio.ch.IOUtil.writeFromNativeBuffer()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">writeFromNativeBuffer</span><span class="params">(FileDescriptor fd, ByteBuffer bb,</span></span></div><div class="line">                                            <span class="keyword">long</span> position, NativeDispatcher nd)</div><div class="line">       <span class="keyword">throws</span> IOException</div><div class="line">   &#123;</div><div class="line">       <span class="keyword">int</span> pos = bb.position();</div><div class="line">       <span class="keyword">int</span> lim = bb.limit();</div><div class="line">       <span class="keyword">assert</span> (pos &lt;= lim);</div><div class="line">       <span class="keyword">int</span> rem = (pos &lt;= lim ? lim - pos : <span class="number">0</span>);</div><div class="line"></div><div class="line">       <span class="keyword">int</span> written = <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (rem == <span class="number">0</span>)</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       <span class="keyword">if</span> (position != -<span class="number">1</span>) &#123;</div><div class="line">          <span class="comment">//不从Buffer头开始写</span></div><div class="line">          <span class="comment">//sun.nio.ch.FileDispatcherImpl.writeFromNativeBuffer()</span></div><div class="line">           written = nd.pwrite(fd,</div><div class="line">                               ((DirectBuffer)bb).address() + pos,</div><div class="line">                               rem, position);</div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">//从Buffer头开始</span></div><div class="line">          <span class="comment">//sun.nio.ch.FileDispatcherImpl.writeFromNativeBuffer()</span></div><div class="line">           written = nd.write(fd, ((DirectBuffer)bb).address() + pos, rem);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (written &gt; <span class="number">0</span>)</div><div class="line">           bb.position(pos + written);</div><div class="line">       <span class="keyword">return</span> written;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>sun.nio.ch.FileDispatcherImpl.writeFromNativeBuffer()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">write</span><span class="params">(FileDescriptor fd, <span class="keyword">long</span> address, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//native调用</span></div><div class="line">    <span class="comment">//源码在openjdk/jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c里面</span></div><div class="line">    <span class="keyword">return</span> write0(fd, address, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接上面，native调用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jint JNICALL</span></div><div class="line"><span class="title">Java_sun_nio_ch_FileDispatcherImpl_write0</span><span class="params">(JNIEnv *env, jclass clazz,</span></div><div class="line">                              jobject fdo, jlong address, jint len)</div><div class="line">&#123;</div><div class="line">    jint fd = fdval(env, fdo);</div><div class="line">    <span class="keyword">void</span> *buf = (<span class="keyword">void</span> *)jlong_to_ptr(address);</div><div class="line">    <span class="comment">//write的原型是</span></div><div class="line">　　<span class="comment">//extern ssize_t write (int __fd, const void *__buf, size_t __n) __wur;</span></div><div class="line">    <span class="keyword">return</span> convertReturnVal(env, write(fd, buf, len), JNI_FALSE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>所以最后，通过系统调用完成IO.操作系统调用接口的原型是：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Write N bytes of BUF to FD.  Return the number written, or -1.</span></div><div class="line"></div><div class="line">   This function is a cancellation point and therefore not marked with</div><div class="line">   __THROW.  */</div><div class="line"><span class="function"><span class="keyword">extern</span> ssize_t <span class="title">write</span> <span class="params">(<span class="keyword">int</span> __fd, <span class="keyword">const</span> <span class="keyword">void</span> *__buf, <span class="keyword">size_t</span> __n)</span> __wur</span>;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FileChannel主要进行文件IO的操作，下面主要分析write()的整个过程，read()和write()是相同的。&lt;/p&gt;
&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要　&quot;&gt;&lt;/a&gt;概要　&lt;/h1&gt;&lt;p
    
    </summary>
    
    
      <category term="IO" scheme="http://YDDMAX.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>openjdk之编译经常出现的问题</title>
    <link href="http://YDDMAX.github.io/2017/06/12/openjdk%E4%B9%8B%E7%BC%96%E8%AF%91%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://YDDMAX.github.io/2017/06/12/openjdk之编译经常出现的问题/</id>
    <published>2017-06-11T16:41:19.000Z</published>
    <updated>2017-06-11T23:33:54.879Z</updated>
    
    <content type="html"><![CDATA[<p>openjdk编译过程中，因为系统环境和openjdk版本等问题，会出现各种问题。本文主要列出两个经常出现的问题及解决办法。</p>
<h1 id="time-is-more-than-10-years-from-present"><a href="#time-is-more-than-10-years-from-present" class="headerlink" title="time is more than 10 years from present"></a>time is more than 10 years from present</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Error: time is more than <span class="number">10</span> years from present: <span class="number">1136059200000</span></div><div class="line">Java.lang.RuntimeException: time is more than <span class="number">10</span> years from present: <span class="number">1136059200000</span></div><div class="line">  at build.tools.generatecurrencydata.GenerateCurrencyData.makeSpecialCaseEntry(GenerateCurrencyData.java:<span class="number">285</span>)</div><div class="line">  at build.tools.generatecurrencydata.GenerateCurrencyData.buildMainAndSpecialCaseTables(GenerateCurrencyData.java:<span class="number">225</span>)</div><div class="line">  at build.tools.generatecurrencydata.GenerateCurrencyData.main(GenerateCurrencyData.java:<span class="number">154</span>)</div></pre></td></tr></table></figure>
<p>解决办法:</p>
<p>修改CurrencyData.properties（路径：jdk/src/share/classes/java/util/CurrencyData.properties）</p>
<p>修改108行<br><code>AZ=AZM;2009-12-31-20-00-00;AZN</code><br>修改381行<br><code>MZ=MZM;2009-06-30-22-00-00;MZN</code><br>修改443行<br><code>RO=ROL;2009-06-30-21-00-00;RON</code><br>修改535行<br><code>TR=TRL;2009-12-31-22-00-00;TRY</code><br>修改561行<br><code>VE=VEB;2009-01-01-04-00-00;VEF</code></p>
<h1 id="OS-is-not-supported-Linux-…-4-0-0-1-amd64-…"><a href="#OS-is-not-supported-Linux-…-4-0-0-1-amd64-…" class="headerlink" title="OS is not supported: Linux … 4.0.0-1-amd64 …"></a>OS is not supported: Linux … 4.0.0-1-amd64 …</h1><p>openjdk在编译时检查linux的内核版本，之前的检查代码没有检查4.x版本(那个时候还没有这个版本的内核)，导致出错。我们只需要在对应的检查代码里加上即可。</p>
<p>在文件hotspot/make/linux/Makefile中，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3%</div><div class="line">+SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 3% 4%</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;openjdk编译过程中，因为系统环境和openjdk版本等问题，会出现各种问题。本文主要列出两个经常出现的问题及解决办法。&lt;/p&gt;
&lt;h1 id=&quot;time-is-more-than-10-years-from-present&quot;&gt;&lt;a href=&quot;#time-is-mor
    
    </summary>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/categories/jvm/"/>
    
    
      <category term="openjdk" scheme="http://YDDMAX.github.io/tags/openjdk/"/>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>openjdk8之编译和debug</title>
    <link href="http://YDDMAX.github.io/2017/06/12/openjdk8%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug/"/>
    <id>http://YDDMAX.github.io/2017/06/12/openjdk8之编译和debug/</id>
    <published>2017-06-11T16:26:56.000Z</published>
    <updated>2017-06-11T23:33:54.879Z</updated>
    
    <content type="html"><![CDATA[<p>系统环境为ubuntu 16.04，uname -a:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linux ddy-Aspire-V5-573G 4.4.0-21-generic <span class="comment">#37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></div></pre></td></tr></table></figure></p>
<p>在本文中，要编译的openjdk版本为:<a href="https://pan.baidu.com/s/1mhLHkc4" target="_blank" rel="external">openjdk-8u40-src-b25-10_feb_2015</a>。<br>尝试了编译<a href="https://pan.baidu.com/s/1jI1cGNc" target="_blank" rel="external">openjdk-8-src-b132-03_mar_2014</a>，但是失败。网上说,因为ubuntu16.04较新，但是该版本的JDK较老，所以失败。</p>
<p>下面说明编译和debug过程。</p>
<h1 id="make版本"><a href="#make版本" class="headerlink" title="make版本"></a>make版本</h1><p>OpenJDK8可以使用”config &amp;&amp; make”编译构建，不再使用Ant和ALT_ *环境变量来配置构建。<br>不过需要GNU make 3.81或更新的版本</p>
<h1 id="安装引导JDK"><a href="#安装引导JDK" class="headerlink" title="安装引导JDK"></a>安装引导JDK</h1><p>我使用的引导JDK是<a href="https://pan.baidu.com/s/1hr6qkOO" target="_blank" rel="external">jdk-7u76-linux-x64</a>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version <span class="string">"1.6.0_45"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.6.0_45-b06)</div><div class="line">Java HotSpot(TM) 64-Bit Server VM (build 20.45-b01, mixed mode)</div></pre></td></tr></table></figure></p>
<h1 id="安装编译工具类库："><a href="#安装编译工具类库：" class="headerlink" title="安装编译工具类库："></a>安装编译工具类库：</h1><p>安装gcc、g++、make等<br><code>sudo apt-get install build-essential</code><br>安装XRender<br><code>sudo apt-get install libxrender-dev</code><br><code>sudo apt-get install xorg-dev</code><br>安装alsa<br><code>sudo apt-get install libasound2-dev</code><br>Cups<br><code>sudo apt-get install libcups2-dev</code><br>安装零碎的工具包<br><code>sudo apt-get install gawk zip libxtst-dev libxi-dev libxt-dev</code></p>
<h1 id="建立编译脚本"><a href="#建立编译脚本" class="headerlink" title="建立编译脚本"></a>建立编译脚本</h1><p>–with-boot-jdk：指定引导JDK所在目录，以防其他安装的JDK影响（本机上以前安装了JDK8，并配置了JAVA_HOME指向JDK8）；<br>–with-target-bits：指定编译64位系统的JDK；</p>
<p>为可以进行源码调试，再指定下面三个参数：<br>–with-debug-level=slowdebug：指定可以生成最多的调试信息；<br>–enable-debug-symbols ZIP_DEBUGINFO_FILES=0：生成调试的符号信息，并且不压缩；<br>在openjdk目录下新建build.sh，内容如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> openjdk  </div><div class="line">bash ./configure --with-target-bits=64 --with-boot-jdk=/usr/java/jdk1.7.0_80/ --with-debug-level=slowdebug --<span class="built_in">enable</span>-debug-symbols ZIP_DEBUGINFO_FILES=0  </div><div class="line">make all ZIP_DEBUGINFO_FILES=0</div></pre></td></tr></table></figure></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>执行<code>./build.sh</code><br>编译完成是这样的：<br><img src="http://oqxil93b6.bkt.clouddn.com/images/openjdk/opjdk-8u40-compile-success.png" alt="openjdk8-compile-success.png"></p>
<h1 id="用GDB测试是否能debug"><a href="#用GDB测试是否能debug" class="headerlink" title="用GDB测试是否能debug"></a>用GDB测试是否能debug</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ ./java -version</div><div class="line">openjdk version <span class="string">"1.8.0-internal-debug"</span></div><div class="line">OpenJDK Runtime Environment (build 1.8.0-internal-debug-ddy_2017_06_11_23_26-b00)</div><div class="line">OpenJDK 64-Bit Server VM (build 25.40-b25-debug, mixed mode)</div><div class="line">ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ <span class="built_in">export</span> CLASSPATH=.:/home/</div><div class="line">ddy/java_src</div><div class="line">ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $ gdb --args java FileChann</div><div class="line">elTest</div><div class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1</div><div class="line">Copyright (C) 2016 Free Software Foundation, Inc.</div><div class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</div><div class="line">This is free software: you are free to change and redistribute it.</div><div class="line">There is NO WARRANTY, to the extent permitted by law.  Type <span class="string">"show copying"</span></div><div class="line">and <span class="string">"show warranty"</span> <span class="keyword">for</span> details.</div><div class="line">This GDB was configured as <span class="string">"x86_64-linux-gnu"</span>.</div><div class="line">Type <span class="string">"show configuration"</span> <span class="keyword">for</span> configuration details.</div><div class="line">For bug reporting instructions, please see:</div><div class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</div><div class="line">Find the GDB manual and other documentation resources online at:</div><div class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</div><div class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">"help"</span>.</div><div class="line">Type <span class="string">"apropos word"</span> to search <span class="keyword">for</span> commands related to <span class="string">"word"</span>...</div><div class="line">Reading symbols from java...done.</div><div class="line">(gdb) <span class="built_in">break</span> init.cpp:95</div><div class="line">No <span class="built_in">source</span> file named init.cpp.</div><div class="line">Make breakpoint pending on future shared library load? (y or [n]) y</div><div class="line">Breakpoint 1 (init.cpp:95) pending.</div><div class="line">(gdb) run</div><div class="line">Starting program: /home/ddy/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin/java FileChannelTest</div><div class="line">[Thread debugging using libthread_db enabled]</div><div class="line">Using host libthread_db library <span class="string">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span>.</div><div class="line">[New Thread 0x7ffff7fc8700 (LWP 9311)]</div><div class="line">[Switching to Thread 0x7ffff7fc8700 (LWP 9311)]</div><div class="line"></div><div class="line">Thread 2 <span class="string">"java"</span> hit Breakpoint 1, init_globals ()</div><div class="line">    at /home/ddy/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/hotspot/src/share/vm/runtime/init.cpp:95</div><div class="line">95	jint <span class="function"><span class="title">init_globals</span></span>() &#123;</div><div class="line">(gdb) l</div><div class="line">90	  chunkpool_init();</div><div class="line">91	  perfMemory_init();</div><div class="line">92	&#125;</div><div class="line">93	</div><div class="line">94	</div><div class="line">95	jint <span class="function"><span class="title">init_globals</span></span>() &#123;</div><div class="line">96	  HandleMark hm;</div><div class="line">97	  management_init();</div><div class="line">98	  bytecodes_init();</div><div class="line">99	  classLoader_init();</div><div class="line">(gdb) quit</div><div class="line">A debugging session is active.</div><div class="line"></div><div class="line">	Inferior 1 [process 9307] will be killed.</div><div class="line"></div><div class="line">Quit anyway? (y or n) y</div><div class="line">ddy@ddy-Aspire-V5-573G ~/openjdk-compile/openjdk-8u40-src-b25-10_feb_2015/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/bin $</div></pre></td></tr></table></figure>
<p><a href="https://yddmax.github.io/2017/06/12/openjdk%E4%B9%8B%E7%BC%96%E8%AF%91%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">openjdk之编译经常出现的问题</a><br><a href="https://yddmax.github.io/2017/06/11/openjdk7%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug/">openjdk7的编译和debug</a><br>编译主要参考：<a href="https://ayonel.me/index.php/2017/01/05/compile_openjdk/" target="_blank" rel="external">ubuntu14.04 编译openjdk7</a><br>debug主要参考：<a href="http://blog.csdn.net/tjiyu/article/details/53725247" target="_blank" rel="external">CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;系统环境为ubuntu 16.04，uname -a:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td 
    
    </summary>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/categories/jvm/"/>
    
    
      <category term="openjdk" scheme="http://YDDMAX.github.io/tags/openjdk/"/>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>openjdk7之编译和debug</title>
    <link href="http://YDDMAX.github.io/2017/06/11/openjdk7%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug/"/>
    <id>http://YDDMAX.github.io/2017/06/11/openjdk7之编译和debug/</id>
    <published>2017-06-11T15:53:55.000Z</published>
    <updated>2017-06-11T23:33:54.879Z</updated>
    
    <content type="html"><![CDATA[<p>为了更好的学习JDK、HotSpot等源码，需要能debug JDK、HotSpot等源码。本文主要讲述，怎么编译openjdk并debug相关源码。<br>在本文中，要编译的openjdk:<a href="https://pan.baidu.com/s/1bFVRwq" target="_blank" rel="external">openjdk-7u40-fcs-src-b43-26_aug_2013.zip</a><br>系统环境为ubuntu 16.04，uname -a:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Linux ddy-Aspire-V5-573G 4.4.0-21-generic <span class="comment">#37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</span></div></pre></td></tr></table></figure></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><ol>
<li>下载源代码<br> openjdk的源码可以通过hg方式下载。　　<br> 也可以从此处下载：<a href="https://pan.baidu.com/s/1qXMoWfM" target="_blank" rel="external">openjdk源码</a>　　</li>
<li><p>安装引导JDK<br> 因为JDK中有很多代码是Java自身实现的，所以还需要一个已经安装在本机上可用的JDK，叫做“Bootstrap     JDK”。我所选用的Bootstarp JDK是JDK1.6.0_45。　　</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java version <span class="string">"1.6.0_45"</span></div><div class="line">Java(TM) SE Runtime Environment (build 1.6.0_45-b06)</div><div class="line">Java HotSpot(TM) Server VM (build 20.45-b01, mixed mode)</div></pre></td></tr></table></figure>
<p> JDK1.6.0_45下载地址：<a href="https://pan.baidu.com/s/1eStdxq6" target="_blank" rel="external">jdk1.6.0_45.tar.gz</a></p>
</li>
<li>安装编译前的依赖环境<br> 安装gcc、g++、make等  　<br> <code>sudo apt-get install build-essential</code>　　<br> 安装ant 1.7以上  　　<br> <code>sudo apt-get install ant</code>　　<br> 安装XRender  　　<br> <code>sudo apt-get install libxrender-dev</code>  　　<br> <code>sudo apt-get install xorg-dev</code> 　　<br> 安装alsa  　　<br> <code>sudo apt-get install libasound2-dev</code>　　<br> Cups  　　<br> <code>sudo apt-get install libcups2-dev</code> 　　<br> 安装零碎的工具包  　　<br> <code>sudo apt-get install gawk zip libxtst-dev libxi-dev libxt-dev</code>　　</li>
<li>配置编译脚本　　<br> 将你的openjdk解压后，并进入该文件夹。比如我的是在/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk<br>下。新建一个build.sh，并添加如下内容：　　 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> LANG=C</div><div class="line"><span class="comment">#将一下两项设置为你的BootstrapJDK安装目录</span></div><div class="line"><span class="built_in">export</span> ALT_BOOTDIR=/home/ddy/jdk1.6.0_45</div><div class="line"><span class="built_in">export</span> ALT_JDK_IMPORT_PATH=/home/ddy/jdk1.6.0_45</div><div class="line"><span class="comment">#允许自动下载依赖包</span></div><div class="line"><span class="built_in">export</span> ALLOW_DOWNLOADS=<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#使用预编译头文件，以提升便以速度</span></div><div class="line"><span class="built_in">export</span> USE_PRECOMPILED_HEADER=<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#要编译的内容，我只选择了LANGTOOLS、HOTSPOT以及JDK</span></div><div class="line"><span class="built_in">export</span> BUILD_LANGTOOLS=<span class="literal">true</span></div><div class="line"><span class="built_in">export</span> BUILD_JAXP=<span class="literal">false</span></div><div class="line"><span class="built_in">export</span> BUILD_JAXWS=<span class="literal">false</span></div><div class="line"><span class="built_in">export</span> BUILD_CORBA=<span class="literal">false</span></div><div class="line"><span class="built_in">export</span> BUILD_HOSTPOT=<span class="literal">true</span></div><div class="line"><span class="built_in">export</span> BUILD_JDK=<span class="literal">true</span></div><div class="line"></div><div class="line"><span class="comment">#要编译的版本</span></div><div class="line"><span class="built_in">export</span> SKIP_DEBUG_BUILD=<span class="literal">false</span></div><div class="line"><span class="built_in">export</span> SKIP_FASTDEBUG_BUILD=<span class="literal">true</span></div><div class="line"><span class="built_in">export</span> DEBUG_NAME=debug</div><div class="line"></div><div class="line"><span class="comment">#避免javaws和浏览器Java插件等的build</span></div><div class="line">BUILD_DEPLOY=<span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">#不build安装包</span></div><div class="line">BUILD_INSTALL=<span class="literal">false</span></div><div class="line"></div><div class="line"><span class="comment">#包含全部的调试信息</span></div><div class="line"><span class="built_in">export</span>  ENABLE_FULL_DEBUG_SYMBOLS=1</div><div class="line"><span class="comment">#调试信息是否压缩，如果配置为１,libjvm.debuginfo会被压缩成libjvm.diz,将不能被debug。</span></div><div class="line"><span class="built_in">export</span>  ZIP_DEBUGINFO_FILES=0</div><div class="line"><span class="comment">#用于编译线程数</span></div><div class="line"><span class="built_in">export</span>  HOTSPOT_BUILD_JOBS=3</div><div class="line"></div><div class="line"><span class="comment">#设置存放编译结果的目录</span></div><div class="line"><span class="comment">#export ALT_OUTPUTDIR=/home/ddy/openjdk/7/build</span></div><div class="line"></div><div class="line"><span class="built_in">unset</span> CLASSPATH</div><div class="line"><span class="built_in">unset</span> JAVA_HOME</div><div class="line">make sanity</div><div class="line">DEBUG_BINARIES=<span class="literal">true</span> make 2&gt;&amp;1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>5.开始编译<br>    在openjdk目录下，运行build.sh<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod +x build.sh</div><div class="line">./build.sh</div></pre></td></tr></table></figure></p>
<pre><code>最后编译耗时将近2分钟。编译完成输出如下信息：
![compile-success][4]
此时openjdk就编译完成了，编译的输出在``/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/``下。
</code></pre><p>进入<code>/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2re-image/bin
n</code>，执行<br>    <code>./java -version</code><br>    输出的java版本信息将是带着你的机器用户名，我的输出是：<br>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openjdk version <span class="string">"1.7.0-internal-debug"</span></div><div class="line">OpenJDK Runtime Environment (build 1.7.0-internal-debug-ddy_2017_06_10_22_30-b00)</div><div class="line">OpenJDK 64-Bit Server VM (build 24.0-b56-jvmg, mixed mode)</div></pre></td></tr></table></figure></p>
<h1 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h1><p>编译完成了之后，就可以对JDK源码和HotSpot源码等进行debug了。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>首先是JDK源码，在build目录下编译生成的jdk里面的jar包都是可编译的了，直接把eclipse的JDK或者JRE换成编译成功的JDK或者JRE即可。</p>
<h2 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h2><p>注意，如果不能进入断点，出现以下类似信息：<br>      <code>Missing separate debuginfo for/root/openjdk/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/libjvm.so</code><br>是因为在编译时因为编译配置项不正确而没有生成调试的符号信息，或生成后被压缩为”libjvm.diz”了，所以无法找到。如果是因为没有编译时没有生成调试信息，需要修改编译配置并重新编译。对于被压缩的情况，可以去到”libjvm.so”所在目录</p>
<ul>
<li>然后解压：unzip libjvm.diz                </li>
<li>解压出来：libjvm.debuginfo</li>
</ul>
<p>如果在编译时，把配置信息修改如下，则不会出现不能上述问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#包含全部的调试信息</span></div><div class="line"><span class="built_in">export</span>  ENABLE_FULL_DEBUG_SYMBOLS=1</div><div class="line"><span class="comment">#调试信息是否压缩，如果配置为１,libjvm.debuginfo会被压缩成libjvm.diz,将不能被debug。</span></div><div class="line"><span class="built_in">export</span>  ZIP_DEBUGINFO_FILES=0</div></pre></td></tr></table></figure></p>
<h3 id="使用GDB"><a href="#使用GDB" class="headerlink" title="使用GDB"></a>使用GDB</h3><p> 参考：<a href="http://blog.csdn.net/tjiyu/article/details/53725247" target="_blank" rel="external">CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码</a></p>
<h3 id="使用eclipse"><a href="#使用eclipse" class="headerlink" title="使用eclipse"></a>使用eclipse</h3><ol>
<li><p>生成要运行的JAVA类<br> 首先在<code>/home/ddy/src/java-src</code>目录下建立要运行的FileChannelTest.java，这个类在写文件时调用了JDK的native方法，其代码如下：　　</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</div><div class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</div><div class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTest</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            FileChannel channel=<span class="keyword">new</span> RandomAccessFile(<span class="string">"test.txt"</span>,<span class="string">"rw"</span>).getChannel();</div><div class="line">            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1000</span>);</div><div class="line">            channel.write(buffer);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 然后对其进行编译,运行:　　</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ddy@ddy-Aspire-V5-573G ~ $ <span class="built_in">cd</span> src/java-src/</div><div class="line">ddy@ddy-Aspire-V5-573G ~/src/java-src $ <span class="built_in">pwd</span></div><div class="line">/home/ddy/src/java-src</div><div class="line">ddy@ddy-Aspire-V5-573G ~/src/java-src $ /home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image/bin/javac FileChannelTest.java</div></pre></td></tr></table></figure>
</li>
<li><p>下载eclipse,安装C/C++插件　<br> 到官网选择一个合适的eclipse下载，因为本人主要进行JAVA开发，所以下载的是j2EE版本，这个版本没有C/C++的功能。不过可以安装插件使其支持C/C++功能。”help -&gt; Eclipse Maketplace”,搜索”c++”找到Eclipse C++ IDE..安装。安装后，就可以转到C++开发视图界面了。</p>
</li>
<li>导入hotspot工程<br> File-&gt; New -&gt; Makefile Project With Existing Code<br> 在界面中:<br> Project Name：openjdk（这个可以自己选择）<br> Existing Code Location：/root/openjdk<br> Toolchain：选Linux GCC，然后按Finish.     </li>
<li>配置源码调试   <ol>
<li>右键工程 -&gt; Debug As -&gt; Debug Configurations -&gt; 右键左边的C/C++ Application -&gt; New -&gt; 进入Main选项卡；<br>在选项卡中:<br><strong>Project：</strong> openjdk（选择导入的openjdk工程）<br><strong>C/C++ Application：</strong>   <code>/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image/bin/java</code>（编译生成的openjdk虚拟机入口）<br><strong>Disable auto build：</strong>因为不再在eclipse里面编译hotspot源码,所以这里选上它；</li>
<li>然后切换到Arguments选项卡, 输入<strong>Java参数</strong>, 这里填上 “FileChannelTest”也就是我们要执行的JAVA程序。</li>
<li>然后切换到Environment选项卡, 添加<strong>变量</strong>：<br><code>JAVA_HOME=/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/build/linux-amd64-debug/j2sdk-image</code>（编译生成JDK所在目录）<br><code>CLASSPATH=.:/home/ddy/src/java-src</code> (FileChannelTest.java文件所在目录)<br>点击下面的Apply保存；</li>
<li>断点Debug<br>　下面分别在源码上打两个断点：<ul>
<li>init.cpp(/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/hotspot/src/share/vm/runtime目录下)      95行</li>
<li>FileDispatchImpl.c(/home/ddy/openjdk-compile/openjdk-7u40-fcs-b43-26/openjdk/jdk/src/solaris/native/sun/nio/ch目录下)    107行</li>
</ul>
</li>
</ol>
</li>
<li><p>然后开始debug。<br> 首先是第一个断点：<br> <img src="http://oqxil93b6.bkt.clouddn.com/images/openjdk/init.cpp-95.png" alt="init.cpp-95.png"></p>
<p> F8进行到下一个断电点：</p>
<p> <img src="http://oqxil93b6.bkt.clouddn.com/images/openjdk/FileDispatcherImpl-write.c.jpg" alt="FileDispatcherImpl-write.c.png"></p>
<p> 从上图可以看到,FileChannel.write()最后调用的是write()操作系统调用。<br> 所以，大家现在可以随便debug　HotSpot的源码和JDK的native源码了。酷！</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yddmax.github.io/2017/06/12/openjdk%E4%B9%8B%E7%BC%96%E8%AF%91%E7%BB%8F%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/">openjdk之编译经常出现的问题</a><br><a href="https://yddmax.github.io/2017/06/12/openjdk8%E4%B9%8B%E7%BC%96%E8%AF%91%E5%92%8Cdebug/">openjdk8的编译和debug</a><br>编译主要参考：<a href="https://ayonel.me/index.php/2017/01/05/compile_openjdk/" target="_blank" rel="external">ubuntu14.04 编译openjdk7</a><br>debug主要参考：<a href="http://blog.csdn.net/tjiyu/article/details/53725247" target="_blank" rel="external">CentOS上编译OpenJDK8源码 以及 在eclipse上调试HotSpot虚拟机源码</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了更好的学习JDK、HotSpot等源码，需要能debug JDK、HotSpot等源码。本文主要讲述，怎么编译openjdk并debug相关源码。&lt;br&gt;在本文中，要编译的openjdk:&lt;a href=&quot;https://pan.baidu.com/s/1bFVRwq
    
    </summary>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/categories/jvm/"/>
    
    
      <category term="openjdk" scheme="http://YDDMAX.github.io/tags/openjdk/"/>
    
      <category term="jvm" scheme="http://YDDMAX.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Buffer</title>
    <link href="http://YDDMAX.github.io/2017/06/08/Buffer/"/>
    <id>http://YDDMAX.github.io/2017/06/08/Buffer/</id>
    <published>2017-06-07T16:13:07.000Z</published>
    <updated>2017-06-07T20:13:32.356Z</updated>
    
    <content type="html"><![CDATA[<p>本机环境：<br><code>Linux  4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux</code></p>
<h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p> Buffer的类图如下：</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/IO/buffer-calss.png" alt="Buffer类图"></p>
<p>除了Boolean，其他基本数据类型都有对应的Buffer，但是只有ByteBuffer才能和Channel交互。<strong>只有ByteBuffer才能产生Direct的buffer</strong>，其他数据类型的Buffer只能产生Heap类型的Buffer。ByteBuffer可以产生其他数据类型的视图Buffer，如果ByteBuffer本身是Direct的，<strong>则产生的各视图Buffer也是Direct的</strong>。</p>
<h2 id="Direct和Heap类型Buffer的本质"><a href="#Direct和Heap类型Buffer的本质" class="headerlink" title="Direct和Heap类型Buffer的本质"></a>Direct和Heap类型Buffer的本质</h2><p>首选说说JVM是怎么进行IO操作的。</p>
<p>JVM在需要通过操作系统调用完成IO操作，比如可以通过read系统调用完成文件的读取。read的原型是：<code>ssize_t read(int fd,void *buf,size_t nbytes)</code>，和其他的IO系统调用类似，一般需要缓冲区作为其中一个参数，该缓冲区要求是连续的。</p>
<p>Buffer分为Direct和Heap两类，下面分别说明这两类buffer。</p>
<h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><p>Heap类型的Buffer存在于JVM的堆上，这部分内存的回收与整理和普通的对象一样。Heap类型的Buffer对象都包含一个对应基本数据类型的数组属性（比如：final **[] hb），数组才是Heap类型Buffer的底层缓冲区。<br>但是Heap类型的Buffer不能作为缓冲区参数直接进行系统调用，主要因为下面两个原因。</p>
<ul>
<li>JVM在GC时可能会移动缓冲区（复制-整理），缓冲区的地址不固定。</li>
<li>系统调用时，缓冲区需要是连续的，但是数组可能不是连续的（JVM的实现没要求连续）。</li>
</ul>
<p>所以使用Heap类型的Buffer进行IO时，JVM需要产生一个临时Direct类型的Buffer，然后进行数据复制，再使用临时Direct的Buffer作为参数进行操作系统调用。这造成很低的效率，主要是因为两个原因：</p>
<ul>
<li>需要把数据从Heap类型的Buffer里面复制到临时创建的Direct的Buffer里面。</li>
<li>可能产生大量的Buffer对象，从而提高GC的频率。<strong>所以在IO操作时，可以通过重复利用Buffer进行优化。</strong></li>
</ul>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><p>Direct类型的buffer，不存在于堆上，而是JVM通过malloc直接分配的一段连续的内存，这部分内存成为直接内存，JVM进行IO系统调用时使用的是直接内存作为缓冲区。<br><code>-XX:MaxDirectMemorySize</code>，通过这个配置可以设置允许分配的最大直接内存的大小（MappedByteBuffer分配的内存不受此配置影响）。<br>直接内存的回收和堆内存的回收不同，如果直接内存使用不当，很容易造成OutOfMemoryError。JAVA没有提供显示的方法去主动释放直接内存，sun.misc.Unsafe类可以进行直接的底层内存操作，通过该类可以主动释放和管理直接内存。<strong>同理，也应该重复利用直接内存以提高效率。</strong></p>
<h2 id="MappedByteBuffer和DirectByteBuffer之间的关系"><a href="#MappedByteBuffer和DirectByteBuffer之间的关系" class="headerlink" title="MappedByteBuffer和DirectByteBuffer之间的关系"></a>MappedByteBuffer和DirectByteBuffer之间的关系</h2><blockquote>
<p><strong>This is a little bit backwards: By rights MappedByteBuffer should be a subclass of DirectByteBuffer, but to keep the spec clear and simple, and for optimization purposes, it’s easier to do it the other way around.This works because DirectByteBuffer is a package-private class.</strong>（本段话摘自MappedByteBuffer的源码）</p>
</blockquote>
<p>实际上，MappedByteBuffer属于映射buffer（自己看看虚拟内存），但是DirectByteBuffer只是说明该部分内存是JVＭ在直接内存区分配的连续缓冲区，并不一是映射的。也就是说MappedByteBuffer应该是DirectByteBuffer的子类，但是为了方便和优化，把MappedByteBuffer作为了DirectByteBuffer的父类。另外，虽然MappedByteBuffer在逻辑上应该是DirectByteBuffer的子类，而且MappedByteBuffer的内存的GC和直接内存的GC类似（和堆GC不同），但是分配的MappedByteBuffer的大小不受-XX:MaxDirectMemorySize参数影响。<br>MappedByteBuffer封装的是内存映射文件操作，也就是只能进行文件IO操作。MappedByteBuffer是根据mmap产生的映射缓冲区，这部分缓冲区被映射到对应的文件页上，属于直接内存在用户态，通过MappedByteBuffer可以直接操作映射缓冲区，而这部分缓冲区又被映射到文件页上，操作系统通过对应内存页的调入和调出完成文件的写入和写出。</p>
<h1 id="MappedByteBuffer"><a href="#MappedByteBuffer" class="headerlink" title="MappedByteBuffer"></a>MappedByteBuffer</h1><p> 通过<code>FileChannel.map(MapMode mode,long position, long size)</code>得到MappedByteBuffer，下面结合源码说明MappedByteBuffer的产生过程。</p>
<p><code>FileChannel.map</code>的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode, <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></div><div class="line">        <span class="keyword">throws</span> IOException</div><div class="line">    &#123;</div><div class="line">        ensureOpen();</div><div class="line">        <span class="keyword">if</span> (position &lt; <span class="number">0L</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative position"</span>);</div><div class="line">        <span class="keyword">if</span> (size &lt; <span class="number">0L</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Negative size"</span>);</div><div class="line">        <span class="keyword">if</span> (position + size &lt; <span class="number">0</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Position + size overflow"</span>);</div><div class="line">        <span class="comment">//最大2G</span></div><div class="line">        <span class="keyword">if</span> (size &gt; Integer.MAX_VALUE)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Size exceeds Integer.MAX_VALUE"</span>);</div><div class="line">        <span class="keyword">int</span> imode = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (mode == MapMode.READ_ONLY)</div><div class="line">            imode = MAP_RO;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == MapMode.READ_WRITE)</div><div class="line">            imode = MAP_RW;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mode == MapMode.PRIVATE)</div><div class="line">            imode = MAP_PV;</div><div class="line">        <span class="keyword">assert</span> (imode &gt;= <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> ((mode != MapMode.READ_ONLY) &amp;&amp; !writable)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NonWritableChannelException();</div><div class="line">        <span class="keyword">if</span> (!readable)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NonReadableChannelException();</div><div class="line"></div><div class="line">        <span class="keyword">long</span> addr = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> ti = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            begin();</div><div class="line">            ti = threads.add();</div><div class="line">            <span class="keyword">if</span> (!isOpen())</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="comment">//size()返回实际的文件大小</span></div><div class="line">            <span class="comment">//如果实际文件大小不符合，则增大文件的大小，文件的大小被改变，文件增大的部分默认设置为0。</span></div><div class="line">            <span class="keyword">if</span> (size() &lt; position + size) &#123; <span class="comment">// Extend file size</span></div><div class="line">                <span class="keyword">if</span> (!writable) &#123;</div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Channel not open for writing "</span> +</div><div class="line">                        <span class="string">"- cannot extend file to required size"</span>);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> rv;</div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                   <span class="comment">//增大文件的大小</span></div><div class="line">                    rv = nd.truncate(fd, position + size);</div><div class="line">                &#125; <span class="keyword">while</span> ((rv == IOStatus.INTERRUPTED) &amp;&amp; isOpen());</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果要求映射的文件大小为0，则不调用操作系统的mmap调用，只是生成一个空间容量为0的DirectByteBuffer</span></div><div class="line">            <span class="comment">//并返回</span></div><div class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</div><div class="line">                addr = <span class="number">0</span>;</div><div class="line">                <span class="comment">// a valid file descriptor is not required</span></div><div class="line">                FileDescriptor dummy = <span class="keyword">new</span> FileDescriptor();</div><div class="line">                <span class="keyword">if</span> ((!writable) || (imode == MAP_RO))</div><div class="line">                    <span class="keyword">return</span> Util.newMappedByteBufferR(<span class="number">0</span>, <span class="number">0</span>, dummy, <span class="keyword">null</span>);</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    <span class="keyword">return</span> Util.newMappedByteBuffer(<span class="number">0</span>, <span class="number">0</span>, dummy, <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//allocationGranularity的大小在我的系统上是4K</span></div><div class="line">            <span class="comment">//页对齐，pagePosition为第多少页</span></div><div class="line">            <span class="keyword">int</span> pagePosition = (<span class="keyword">int</span>)(position % allocationGranularity);</div><div class="line">            <span class="comment">//从页的最开始映射</span></div><div class="line">            <span class="keyword">long</span> mapPosition = position - pagePosition;</div><div class="line">            <span class="comment">//因为从页的最开始映射，增大映射空间</span></div><div class="line">            <span class="keyword">long</span> mapSize = size + pagePosition;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// If no exception was thrown from map0, the address is valid</span></div><div class="line">                <span class="comment">//native方法，源代码在openjdk/jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c,</span></div><div class="line">                <span class="comment">//参见下面的说明</span></div><div class="line">                addr = map0(imode, mapPosition, mapSize);</div><div class="line">            &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</div><div class="line">                <span class="comment">// An OutOfMemoryError may indicate that we've exhausted memory</span></div><div class="line">                <span class="comment">// so force gc and re-attempt map</span></div><div class="line">                System.gc();</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">100</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException y) &#123;</div><div class="line">                    Thread.currentThread().interrupt();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    addr = map0(imode, mapPosition, mapSize);</div><div class="line">                &#125; <span class="keyword">catch</span> (OutOfMemoryError y) &#123;</div><div class="line">                    <span class="comment">// After a second OOME, fail</span></div><div class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Map failed"</span>, y);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// On Windows, and potentially other platforms, we need an open</span></div><div class="line">            <span class="comment">// file descriptor for some mapping operations.</span></div><div class="line">            FileDescriptor mfd;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                mfd = nd.duplicateForMapping(fd);</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">                unmap0(addr, mapSize);</div><div class="line">                <span class="keyword">throw</span> ioe;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">assert</span> (IOStatus.checkAll(addr));</div><div class="line">            <span class="keyword">assert</span> (addr % allocationGranularity == <span class="number">0</span>);</div><div class="line">            <span class="keyword">int</span> isize = (<span class="keyword">int</span>)size;</div><div class="line">            Unmapper um = <span class="keyword">new</span> Unmapper(addr, mapSize, isize, mfd);</div><div class="line">            <span class="keyword">if</span> ((!writable) || (imode == MAP_RO)) &#123;</div><div class="line">                <span class="keyword">return</span> Util.newMappedByteBufferR(isize,</div><div class="line">                                                 addr + pagePosition,</div><div class="line">                                                 mfd,</div><div class="line">                                                 um);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> Util.newMappedByteBuffer(isize,</div><div class="line">                                                addr + pagePosition,</div><div class="line">                                                mfd,</div><div class="line">                                                um);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            threads.remove(ti);</div><div class="line">            end(IOStatus.checkAll(addr));</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><code>map0</code>的源码实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jlong JNICALL</span></div><div class="line"><span class="title">Java_sun_nio_ch_FileChannelImpl_map0</span><span class="params">(JNIEnv *env, jobject <span class="keyword">this</span>,</span></div><div class="line">                                     jint prot, jlong off, jlong len)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> *mapAddress = <span class="number">0</span>;</div><div class="line">    jobject fdo = (*env)-&gt;GetObjectField(env, <span class="keyword">this</span>, chan_fd);</div><div class="line">    <span class="comment">//linux系统调用是通过整型的文件id引用文件的，这里得到文件id</span></div><div class="line">    jint fd = fdval(env, fdo);</div><div class="line">    <span class="keyword">int</span> protections = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RO) &#123;</div><div class="line">        protections = PROT_READ;</div><div class="line">        flags = MAP_SHARED;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_RW) &#123;</div><div class="line">        protections = PROT_WRITE | PROT_READ;</div><div class="line">        flags = MAP_SHARED;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prot == sun_nio_ch_FileChannelImpl_MAP_PV) &#123;</div><div class="line">        protections =  PROT_WRITE | PROT_READ;</div><div class="line">        flags = MAP_PRIVATE;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里就是操作系统调用了，mmap64是宏定义，实际最后调用的是mmap</span></div><div class="line">    mapAddress = mmap64(</div><div class="line">        <span class="number">0</span>,                    <span class="comment">/* Let OS decide location */</span></div><div class="line">        len,                  <span class="comment">/* Number of bytes to map */</span></div><div class="line">        protections,          <span class="comment">/* File permissions */</span></div><div class="line">        flags,                <span class="comment">/* Changes are shared */</span></div><div class="line">        fd,                   <span class="comment">/* File descriptor of mapped file */</span></div><div class="line">        off);                 <span class="comment">/* Offset into file */</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mapAddress == MAP_FAILED) &#123;</div><div class="line">        <span class="keyword">if</span> (errno == ENOMEM) &#123;</div><div class="line">            <span class="comment">//如果没有映射成功，直接抛出OutOfMemoryError</span></div><div class="line">            JNU_ThrowOutOfMemoryError(env, <span class="string">"Map failed"</span>);</div><div class="line">            <span class="keyword">return</span> IOS_THROWN;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> handle(env, <span class="number">-1</span>, <span class="string">"Map failed"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ((jlong) (<span class="keyword">unsigned</span> <span class="keyword">long</span>) mapAddress);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然<code>FileChannel.map()</code>的zise参数是long，但是size的大小最大为Integer.MAX_VALUE,也就是最大只能映射最大2G大小的空间。实际上操作系统提供的MMAP可以分配更大的空间，但是JAVA限制在2G，ByteBuffer等Buffer也最大只能分配2G大小的缓冲区。<br>MappedByteBuffer是通过mmap产生得到的缓冲区，这部分缓冲区是由操作系统直接创建和管理的，最后JVM通过unmmap让操作系统直接释放这部分内存。</p>
<h1 id="Haep-Buffer"><a href="#Haep-Buffer" class="headerlink" title="Haep**Buffer"></a>Haep<em>**</em>Buffer</h1><p>下面以ByteBuffer为例，说明Heap类型Buffer的细节。<br>该类型的Buffer可以通过下面方式产生：</p>
<ul>
<li><code>ByteBuffer.allocate(int capacity)</code></li>
<li><code>ByteBuffer.wrap(byte[] array)</code><br>使用传入的数组作为底层缓冲区，变更数组会影响缓冲区，变更缓冲区也会影响数组。</li>
<li><code>ByteBuffer.wrap(byte[] array,int offset, int length)</code><br>使用传入的数组的一部分作为底层缓冲区，变更数组的对应部分会影响缓冲区，变更缓冲区也会影响数组。</li>
</ul>
<h1 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h1><p>  DirectByteBuffer只能通过<code>ByteBuffer.allocateDirect(int capacity)</code> 产生。<br>  <code>ByteBuffer.allocateDirect()</code>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <code>DirectByteBuffer()</code>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">DirectByteBuffer(int cap) &#123;                   // package-private</div><div class="line"></div><div class="line">    super(-1, 0, cap, cap);</div><div class="line">    //直接内存是否要页对齐，我本机测试的不用</div><div class="line">    boolean pa = VM.isDirectMemoryPageAligned();</div><div class="line">    //页的大小，本机测试的是4K</div><div class="line">    int ps = Bits.pageSize();</div><div class="line">    //如果页对齐，则size的大小是ps+cap，ps是一页，cap也是从新的一页开始，也就是页对齐了</div><div class="line">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</div><div class="line">    //JVM维护所有直接内存的大小，如果已分配的直接内存加上本次要分配的大小超过允许分配的直接内存的最大值会</div><div class="line">    //引起GC，否则允许分配并把已分配的直接内存总量加上本次分配的大小。如果GC之后，还是超过所允许的最大值，</div><div class="line">    //则throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</div><div class="line">    Bits.reserveMemory(size, cap);</div><div class="line"></div><div class="line">    long base = 0;</div><div class="line">    try &#123;</div><div class="line">       //是吧，unsafe可以直接操作底层内存</div><div class="line">        base = unsafe.allocateMemory(size);</div><div class="line">    &#125; catch (OutOfMemoryError x) &#123;、</div><div class="line">        //没有分配成功，把刚刚加上的已分配的直接内存的大小减去。</div><div class="line">        Bits.unreserveMemory(size, cap);</div><div class="line">        throw x;</div><div class="line">    &#125;</div><div class="line">    unsafe.setMemory(base, size, (byte) 0);</div><div class="line">    if (pa &amp;&amp; (base % ps != 0)) &#123;</div><div class="line">        // Round up to page boundary</div><div class="line">        address = base + ps - (base &amp; (ps - 1));</div><div class="line">    &#125; else &#123;</div><div class="line">        address = base;</div><div class="line">    &#125;</div><div class="line">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</div><div class="line">    att = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>unsafe.allocateMemory()</code>的源码在openjdk/src/openjdk/hotspot/src/share/vm/prims/unsafe.cpp中。具体的源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</div><div class="line">  UnsafeWrapper(<span class="string">"Unsafe_AllocateMemory"</span>);</div><div class="line">  <span class="keyword">size_t</span> sz = (<span class="keyword">size_t</span>)size;</div><div class="line">  <span class="keyword">if</span> (sz != (julong)size || size &lt; <span class="number">0</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_IllegalArgumentException());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  sz = round_to(sz, HeapWordSize);</div><div class="line">  <span class="comment">//最后调用的是 u_char* ptr = (u_char*)::malloc(size + space_before + space_after)，也就是malloc。</span></div><div class="line">  <span class="keyword">void</span>* x = os::<span class="built_in">malloc</span>(sz, mtInternal);</div><div class="line">  <span class="keyword">if</span> (x == <span class="literal">NULL</span>) &#123;</div><div class="line">    THROW_0(vmSymbols::java_lang_OutOfMemoryError());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></div><div class="line">  <span class="keyword">return</span> addr_to_java(x);</div><div class="line">UNSAFE_END</div></pre></td></tr></table></figure></p>
<p>JVM通过malloc分配得到连续的缓冲区，这部分缓冲区可以直接作为缓冲区参数进行操作系统调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本机环境：&lt;br&gt;&lt;code&gt;Linux  4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;Buff
    
    </summary>
    
      <category term="java" scheme="http://YDDMAX.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://YDDMAX.github.io/tags/java/"/>
    
      <category term="Buffer" scheme="http://YDDMAX.github.io/tags/Buffer/"/>
    
  </entry>
  
  <entry>
    <title>JDK源码之编译</title>
    <link href="http://YDDMAX.github.io/2017/06/05/JDK%E6%BA%90%E7%A0%81%E4%B9%8B%E7%BC%96%E8%AF%91/"/>
    <id>http://YDDMAX.github.io/2017/06/05/JDK源码之编译/</id>
    <published>2017-06-05T13:19:58.000Z</published>
    <updated>2017-06-07T08:27:28.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说明如何编译组成rt.jar的源码，不涉及JVM的编译。</p>
<h1 id="rt-jar"><a href="#rt-jar" class="headerlink" title="rt.jar"></a>rt.jar</h1><p>rt.jar也就是运行时相关的class类，安装的jre里面的rt.jar是不能被debug的，为了对JDK的源码进行debug跟踪，需要重新编译rt.jar。<br>rt.jar的全部源码在openjdk的jdk目录下，具体的路径是openjdk\jdk\src\，源码根据操作系统的不同和是否共享分成几个目录。<br><strong>实际上rt.jar因为操作系统的不同，所包含的class也会有所不同，这导致在一些特殊特性上JAVA不再是“一次编译，到处执行”。</strong><br><strong>比如，在java7中，linux/unix下的jre支持<code>com.sun.java.swing.plaf.gtk.GTKLookAndFeel</code></strong>,但是windows就不支持。<br>操作系统安装的JDK里面的src.zip不包含<strong>sun.*包</strong>，<strong><em>sun.\</em></strong>包在openjdk源码里面,具体的路径是：<strong>jdk\src\share\classes</strong>。<br>src.zip除了缺少sun.*包，还缺少其他源代码，不过这些源代码都能在share目录和各操作系统对应目录下找到。<br>openjdk的目录说明和源码下载参见：<a href="https://yddmax.github.io/2017/06/05/openjdk%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95/">openjdk目录</a></p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>本文编译的是openjdk-7里面jdk目录下的源码。</p>
<ol>
<li>新建java project</li>
<li>将openjdk源码copy到project中。除了复制share目录下的共享源码，还需要复制具体操作系统下的源码。</li>
<li>编译导出jar。</li>
</ol>
<p>参考资料：<a href="http://bijian1013.iteye.com/blog/2302520" target="_blank" rel="external">怎么对jdk核心包进行跟踪调试，并查看调试中的变量值</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说明如何编译组成rt.jar的源码，不涉及JVM的编译。&lt;/p&gt;
&lt;h1 id=&quot;rt-jar&quot;&gt;&lt;a href=&quot;#rt-jar&quot; class=&quot;headerlink&quot; title=&quot;rt.jar&quot;&gt;&lt;/a&gt;rt.jar&lt;/h1&gt;&lt;p&gt;rt.jar也就是运行时相关
    
    </summary>
    
      <category term="java" scheme="http://YDDMAX.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://YDDMAX.github.io/tags/java/"/>
    
      <category term="JDK" scheme="http://YDDMAX.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>openjdk源码目录</title>
    <link href="http://YDDMAX.github.io/2017/06/05/openjdk%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95/"/>
    <id>http://YDDMAX.github.io/2017/06/05/openjdk源码目录/</id>
    <published>2017-06-05T12:53:40.000Z</published>
    <updated>2017-06-05T08:06:35.234Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考自：<a href="http://blog.csdn.net/socrj/article/details/43916221" target="_blank" rel="external">openjdk源码结构</a></p>
<h1 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h1><p>openjdk-7的源码：<a href="http://pan.baidu.com/s/1qYAtBK4" target="_blank" rel="external">openjdk7源码</a><br>openjdk-8的源码：<a href="http://download.csdn.net/download/socrj/8454221" target="_blank" rel="external">openJDK8源码</a></p>
<h1 id="目录说明"><a href="#目录说明" class="headerlink" title="目录说明"></a>目录说明</h1><p>openjdk的源码的目录结构如下图所示：<br><img src="http://oqxil93b6.bkt.clouddn.com/images/openjdk%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84openjdk-source-structure.png" alt="此处输入图片的描述"></p>
<p>各个目录的说明如下：<br><strong>—— corba：不流行的多语言、分布式通讯接口<br>—— hotspot：Java 虚拟机<br>—— jaxp：XML 处理<br>—— jaxws：一组 XML web services 的 Java API<br>—— jdk：java 开发工具包<br>—— —— 针对操作系统的部分<br>—— —— share：与平台无关的实现<br>—— langtools：Java 语言工具<br>—— nashorn：JVM 上的 JavaScript 运行时</strong></p>
<p>为了让大家易于理解，有所简化了结构。</p>
<h2 id="Corba"><a href="#Corba" class="headerlink" title="Corba"></a>Corba</h2><p>全称 Common Object Request Broker Architecture，通用对象请求代理架构，是基于 对象-服务 机制设计得。</p>
<p>与 JavaBean、COM 等是同种范畴。</p>
<p>目前，通用的远程过程调用协议是 SOAP（Simple Object Access Protocol，简单对象访问协议），消息格式是 XML-RPC（存在 Json-RPC）。<br>另外，Apache Thrift 提供了多语言 C/S 通讯支持； 不少语言也内置了跨语言调用或对分布式环境友好，比如： lua 可以与 c 代码互调用，Go 可以调用 C 代码，erlang 在本地操作与分布式环境下的操作方法一样等。<br><strong>Corba和RMI类似，都能实现RPC。但是RMI只是针对JAVA环境的，Corba是支持多语言的方案</strong></p>
<h2 id="Hotspot"><a href="#Hotspot" class="headerlink" title="Hotspot"></a>Hotspot</h2><p>全称 Java HotSpot Performance Engine，是 Java 虚拟机的一个实现，包含了服务器版和桌面应用程序版。利用 JIT 及自适应优化技术（自动查找性能热点并进行动态优化）来提高性能。</p>
<p>使用 java -version 可以查看 Hotspot 的版本。</p>
<p>从 Java 1.3 起为默认虚拟机，现由 Oracle 维护并发布。</p>
<p>其他 java 虚拟机：</p>
<ul>
<li>JRockit：专注于服务器端，曾经号称是“世界上速度最快的 Java 虚拟机”，现归于 Oracle 旗下。</li>
<li>J9：IBM 设计的 Java 虚拟机。</li>
<li>Harmony：Apache 的顶级项目之一，从 2011 年 11 月 6 日起入驻 Apache 的 Java 项目。虽然其能够兼容 jdk，但由于 JCP （Java Community Process）仅仅允许授权给 Harmony 一个带有限制条件的TCK（Technology Compatibility Kit），即仅仅能使用在 J2SE ,而不是所有Java实现上（包括 J2ME 和 J2EE），导致了 Apache 组织与 Oracle 的决裂。Harmony 是 Android 虚拟机 Dalvik 的前身。</li>
<li>Dalvik 并不是 Java 虚拟机，它执行的是 dex 文件而不是 class 文件，使用的也是寄存器架构而不是栈架构 。</li>
</ul>
<h2 id="jaxp"><a href="#jaxp" class="headerlink" title="jaxp"></a>jaxp</h2><p>全称 Java API for XML Processing，处理 XML 的Java API，是 Java XML 程序设计的应用程序接口之一，它提供解析和验证XML文档的能力。<br>jaxp 提供了处理 xml 文件的三种接口：</p>
<ul>
<li>DOM 接口（文档对象模型解析），位于 \openjdk\jaxp\src\org\w3c\dom</li>
<li>SAX 接口（xml 简单 api 解析），位于 \openjdk\jaxp\src\org\xml\sax</li>
<li>StAX 接口（xml 流 api），位于 \openjdk\jaxp\src\javax\xml</li>
<li>除了解析接口，JAXP还提供了XSLT接口用来对XML文档进行数据和结构的转换。</li>
</ul>
<h2 id="JaxWS"><a href="#JaxWS" class="headerlink" title="JaxWS"></a>JaxWS</h2><p>全称 Java API for Web Services，JAX-WS 允许开发者选择 RPC-oriented（面向 RPC） 或者 message-oriented（消息通信，erlang 使用的就是消息通信，不过 Java 内存模型是内存共享）来实现自己的web services。</p>
<p>通过 Web Services 提供的环境，可以实现 Java 与其他编程语言的交互（事实上就是 thrift 所做的，任何一种语言都可以通过 Web Services 实现与其他语言的通信，客户端用一种语言，服务器端可以用其他语言）。</p>
<h2 id="LangTools"><a href="#LangTools" class="headerlink" title="LangTools"></a>LangTools</h2><p>Java 语言支持工具</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>全称 Java Development Kit。</p>
<p><strong>share</strong></p>
<p><strong>classes</strong> 目录里的是 Java 的实现，<strong>native</strong> 目录里的是 C++ 的实现，两部分基本对应。这两个目录里的结构与 java 的包也是对应，各个部分的用途另外再讲。</p>
<p>back、instrument、javavm、npt、transport 几个部分是实现 java 的基础部分，都是 C++ 代码，在这里从最底层理解 java，往后这些内容也会详讲。</p>
<p>sample 和 demo 目录有以下示例，区别在于 demo 目录是 针对 applets 的。</p>
<h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a>Nashorn</h2><p>Nashorn 项目的目的是基于 Java 在 JVM 上实现一个轻量级高性能的 JavaScript 运行环境。基于 JSR-223 协议，Java 程序员可在 Java 程序中嵌入 JavaScript 代码。<br>该项目使用了 JSR-229 里描述的新连接机制（从 Java7起开始使用的连接机制）：新的字节码（invokedynamic）以及新的基于方法句柄（method handle）的连接机制。通过接口注入（interface injection）在运行时修改类也是 JSR-229 里的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要参考自：&lt;a href=&quot;http://blog.csdn.net/socrj/article/details/43916221&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;openjdk源码结构&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;源码下载&quot;&gt;&lt;a
    
    </summary>
    
      <category term="java" scheme="http://YDDMAX.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://YDDMAX.github.io/tags/java/"/>
    
      <category term="JDK" scheme="http://YDDMAX.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>JAVA IO</title>
    <link href="http://YDDMAX.github.io/2017/06/04/JAVA-IO/"/>
    <id>http://YDDMAX.github.io/2017/06/04/JAVA-IO/</id>
    <published>2017-06-04T06:14:39.000Z</published>
    <updated>2017-06-05T08:06:06.661Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机IO"><a href="#计算机IO" class="headerlink" title="计算机IO"></a>计算机IO</h1><p>本部分内容主要参考自《JAVA NIO》的第一章简介。</p>
<h2 id="缓冲区操作"><a href="#缓冲区操作" class="headerlink" title="缓冲区操作"></a>缓冲区操作</h2><p>下图简单描述了数据从外部磁盘向运行中的进程的内存区域移动的过程。<br>进程使用 read( )系统调用，要求其缓冲区被填满。内核随即向磁盘控制硬件发出命令，要求其从磁盘读取数据。磁盘控制器把数据直接写入内核内存缓冲区，<strong>这一步通过 DMA 完成，无需主 CPU 协助</strong>。一旦磁盘控制器把缓冲区装满，内核即把数据从内核空间的临时缓冲区拷贝到进程执行 read()调用时指定的缓冲区。<br>  <img src="http://oqxil93b6.bkt.clouddn.com/images/JAVA%20IO/buffer-io.png" alt="缓冲区操作"><br>为什么不让磁盘控制器直接将磁盘上数据直接copy到用户缓冲区呢？</p>
<ul>
<li>硬件无法直接访问用户空间</li>
<li><p>像磁盘这样基于块存储的硬件设备操作的是固定大小的数据块，而用户进程请求的可能是任意大小的或非对齐的数据块。在数据往来于用户空间与存储设备的过程中，内核负责<br>数据的分解、再组合工作，因此充当着中间人的角色。 </p>
<h2 id="发散和汇聚"><a href="#发散和汇聚" class="headerlink" title="发散和汇聚"></a>发散和汇聚</h2><p>根据发散／汇聚的概念，进程只需一个系统调用，就能把一连串缓冲区地址传递给操作系统。然后，内核就可以顺序填充或排干多个缓冲区，读的时候就把数据发散到多个用户空间缓冲区，写的时候再从多个缓冲区把数据汇聚起来（如下图所示）。<br><img src="http://oqxil93b6.bkt.clouddn.com/images/JAVA%20IO/scatter-gather.png" alt="发散和汇聚"><br>优点：</p>
</li>
<li><p>这样用户进程就不必多次执行系统调用（那样做可能代价不菲）</p>
</li>
<li>内核也可以优化数据的处理过程，因为它已掌握待传输数据的全部信息。</li>
<li>如果系统配有多个 CPU，甚至可以同时填充或排干多个缓冲区。</li>
<li><p>多个缓冲区可能方便一些特定协议的编程（自己加的）。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>现代操作系统都支持虚拟内存，CPU为了更好的支持虚拟内存也加入了MMU（内存管理单元）。在寻址时，需要把虚拟地址经过MMU计算得到真实的物理地址，然后再去寻址。<br>虚拟内存的好处：</p>
</li>
<li><p>一个以上的虚拟地址可指向同一个物理内存地址。</p>
</li>
<li><p>虚拟内存空间可大于实际可用的硬件内存。</p>
<h2 id="内存页面调度"><a href="#内存页面调度" class="headerlink" title="内存页面调度"></a>内存页面调度</h2><p><strong>为了支持虚拟内存，需要把内存存储到硬盘上，现代操作系统是通过内存页面调度实现的。对于采用分页技术的现代操作系统而言，这也是数据在磁盘与物理内存之间往来的唯一方式。</strong><br>下面的步骤说明了内存页面调度的过程：</p>
</li>
<li><p>当 CPU 引用某内存地址时，MMU负责确定该地址所在页（往往通过对地址值进行移位或屏蔽位操作实现），并将虚拟页号转换为物理页号（这一步由硬件完成，速度极快）。如果当前不存在与该虚拟页形成有效映射的物理内存页，MMU 会向 CPU 提交一个页错误。</p>
</li>
<li>页错误随即产生一个陷阱（类似于系统调用），把控制权移交给内核，附带导致错误的虚拟地址信息，然后内核采取步骤验证页的有效性。内核会安排页面调入操作，把缺失的页内容读回物理内存。这往往导致别的页被移出物理内存，好给新来的页让地方。在这种情况下，如果待移出的页已经被碰过了（自创建或上次页面调入以来，内容已发生改变），还必须首先执行页面调出，把页内容拷贝到磁盘上的分页区。</li>
<li><p>如果所要求的地址不是有效的虚拟内存地址（不属于正在执行的进程的任何一个内存段），则该页不能通过验证，段错误随即产生。于是，控制权转交给内核的另一部分，通常导致的结果就是进程被强令关闭。<br>一旦出错的页通过了验证，MMU 随即更新，建立新的虚拟到物理的映射（如有必要，中断被移出页的映射），用户进程得以继续。造成页错误的用户进程对此不会有丝毫察觉，一切都在不知不觉中进行。</p>
<h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><p><strong>虚拟内存通过页面调度可以调度内存页和硬盘页，现代操作系统对文件IO的操作也是基于页面调度实现的。</strong><br>采用分页技术的操作系统执行 I/O 的全过程可总结为以下几步：</p>
</li>
<li><p>确定请求的数据分布在文件系统的哪些页（磁盘扇区组）。磁盘上的文件内容和元数<br>据可能跨越多个文件系统页，而且这些页可能也不连续。</p>
</li>
<li>在内核空间分配足够数量的内存页，以容纳得到确定的文件系统页。</li>
<li>在内存页与磁盘上的文件系统页之间建立映射。</li>
<li>为每一个内存页产生页错误。</li>
<li>虚拟内存系统俘获页错误，安排页面调入，从磁盘上读取页内容，使页有效。</li>
<li><p>一旦页面调入操作完成，文件系统即对原始数据进行解析，取得所需文件内容或属性信息。</p>
<h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><strong>为了在内核空间的文件系统页与用户空间的内存区之间移动数据，<code>一次以上的拷贝操作几乎总是免不了的</code>。这是因为，在文件系统页与用户缓冲区之间往往没有一一对应关系。</strong>但是，还有一种大多数操作系统都支持的特殊类型的 I/O 操作，允许用户进程最大限度地利用面向页的系统 I/O 特性，并完全摒弃缓冲区拷贝。这就是内存映射 I/O。<br><strong>内存映射文件将内存页全部映射到文件的硬盘块上，存在一一映射关系。使用内存映射文件时，用户态是没有缓冲区的，只存在映射到硬盘页的内存页面缓冲区，所以是真正的ZeroCopy。而不使用内存映射文件的IO，因为直接内存和内存页缓冲区没有映射关系，所以使使用直接内存作为缓冲区也是需要最少一次copy的。</strong><code>（那文件IO时使用直接内存的好处是什么？）</code></p>
<h3 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h3><p>JVM实现的是进程之间的锁定，一个进程之间的多个线程之间是不锁定的。<br>支持共享锁、独占锁等<br>支持锁定文件的部分区域，粒度支持到字节。</p>
<h3 id="流IO"><a href="#流IO" class="headerlink" title="流IO"></a>流IO</h3><p>流的传输一般（也不必然如此）比块设备慢，经常用于间歇性输入。多数操作系统允许把流置于非块模式，这样，进程可以查看流上是否有输入，即便当时没有也不影响它干别的。这样一种能力使得进程可以在有输入的时候进行处理，输入流闲置的时候执行其他功能。<br>处理流IO需要依赖操作系统的通知机制：</p>
</li>
<li><p>Selector通知已就绪，可以进行相关IO操作。</p>
</li>
<li>AIO通知IO操作已完成，可以处理相关业务逻辑了。</li>
</ul>
<h1 id="JAVA-IO-发展和总结"><a href="#JAVA-IO-发展和总结" class="headerlink" title="JAVA IO 发展和总结"></a>JAVA IO 发展和总结</h1><p>BIO 抽象工作良好，适应用途广泛。但是当<strong>移动大量数据</strong>时，这些 I/O 类可伸缩性不强，也没有提供当今大多数操作系统普遍具备的常用 I/O 功能，如<strong>文件锁定</strong>、<strong>非块 I/O</strong>、<strong>就绪性选择</strong>和<strong>内存映射</strong>。这些特性对实现可伸缩性是至关重要的，对保持与非 Java 应用程序的正常交互也可以说是必不可少的，尤其是在企业应用层面，而传统的 Java I/O 机制却没有模拟这些通用 I/O 服务。操作系统与 Java 基于流的 I/O模型有些不匹配。操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（DMA）的协助下完成的。<strong>BIO 类喜欢操作小块数据——单个字节、几行文本。</strong></p>
<ul>
<li>BIO<br>JDK版本：1.1<br>时间：<br>特点：</li>
</ul>
<ol>
<li>同步阻塞</li>
<li>面向流（字节流和字符流）</li>
<li>不支持操作系统支持的很多IO概念和特性</li>
<li>read()操作返回所读的字节数，write操作没有返回值</li>
<li>read是SeekAble的（支持skip），write不是Seekable的。</li>
</ol>
<ul>
<li>NIO.1<br>JDK版本：1.4<br>时间：2002<br>特点：</li>
</ul>
<ol>
<li>针对现代操作系统重新抽象和封装实现了Channel和Buffer</li>
<li>网络IO支持配置是否阻塞，文件IO只能是阻塞的</li>
<li>网络IO支持多路复用（异步），使用多路复用时，Channel必须是非阻塞模式，而且阻塞模式不能再被修改</li>
<li>网络IO和文件IO都是可中断的。文件IO过程中被中断时，JVM会关闭Channel。</li>
<li>支持直接Buffer、支持内存映射文件</li>
<li>支持文件锁定，但是是进程级别的锁定</li>
<li>支持Pipe</li>
<li>read操作返回所读的字节数，write操作返回所写的字节数</li>
<li>Channel是全双工的。虽然RandomAccessFile也可以是全双工的，但是Channel这种封装方式更好</li>
</ol>
<ul>
<li>NIO.2（AIO）<br>JDK版本：1.7<br>时间：2011<br>特点：</li>
</ul>
<ol>
<li>文件IO和网络IO是异步的（当然是非阻塞的），异步形式是future和callback。</li>
<li>Watch Service</li>
<li>文件IO支持更丰富的API</li>
</ol>
<h1 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h1><h1 id="NIO-1"><a href="#NIO-1" class="headerlink" title="NIO.1"></a>NIO.1</h1><h1 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h1><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="Watch-Service"><a href="#Watch-Service" class="headerlink" title="Watch Service"></a>Watch Service</h3><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h2 id="更丰富的文件操作"><a href="#更丰富的文件操作" class="headerlink" title="更丰富的文件操作"></a>更丰富的文件操作</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;计算机IO&quot;&gt;&lt;a href=&quot;#计算机IO&quot; class=&quot;headerlink&quot; title=&quot;计算机IO&quot;&gt;&lt;/a&gt;计算机IO&lt;/h1&gt;&lt;p&gt;本部分内容主要参考自《JAVA NIO》的第一章简介。&lt;/p&gt;
&lt;h2 id=&quot;缓冲区操作&quot;&gt;&lt;a href=&quot;#缓
    
    </summary>
    
      <category term="technology" scheme="http://YDDMAX.github.io/categories/technology/"/>
    
    
      <category term="IO" scheme="http://YDDMAX.github.io/tags/IO/"/>
    
      <category term="JAVA" scheme="http://YDDMAX.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Pro Java 7 NIO 2读书笔记</title>
    <link href="http://YDDMAX.github.io/2017/06/04/Pro-Java-7-NIO-2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://YDDMAX.github.io/2017/06/04/Pro-Java-7-NIO-2读书笔记/</id>
    <published>2017-06-04T03:44:38.000Z</published>
    <updated>2017-06-04T04:18:23.637Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.tuicool.com/articles/IRfIJ3" target="_blank" rel="external">转自</a><br> <img src="http://oqxil93b6.bkt.clouddn.com/images/Pro%20Java%207%20NIO%202%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/pro-java7-nio.png" alt="Pro Java 7 NIO.2"><br>花了几天把这本书初略的看了一下， 之所以初略的看了一下，是因为这书里确实没啥内容。如果去了NIO 1的内容和大段大段的代码， 基本上压缩到50页应该没问题。 </p>
<p>下面简单的罗列一下看到的内容： </p>
<h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>这个类在java.nio.file，在NIO里对文件系统进行了进一步的抽象。 是用来替换原来的java.io.File。其中 FileSystems, Files, Path, PathMatcher 成为一个体系。 </p>
<p>在java7里File和Path可以相互转换： File.toPath(), Path.toFile()<br>原来的File里包含了文件引用和文件，在Path系统里， Path里是文件的引用，而文件操作都放到了Files的静态方法里。这种方式究竟好不好用，我没啥感觉。不过我个人偏向于把操作放到另外一个类里面。 </p>
<p>获得Path实例的方式：<br><code>File.toPath(), Paths.get(), FileSystem.getPath()</code></p>
<p>注意： Path和File一样，能创建出实例不代表着这个文件一定在文件系统里真是存在。 </p>
<p>Path和File相比使用上方便了的地方： </p>
<p><strong>不用特意指定路径的separator：</strong><br><code>Paths.get(&quot;C:&quot;,&quot;folder1&quot;,&quot;subfolder&quot;,&quot;aa.txt&quot;)</code></p>
<p>在windows系统了是C:\folder1\subfolder\aa.txt<br>在Mac下是C:/folder/subfolder/aa.txt<br>Java会根据当前操作系统来决定separator </p>
<p><strong>重复利用基本路径：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//define the fixed path</span></div><div class="line">Path base = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009"</span>);</div><div class="line"><span class="comment">//resolve BNP.txt file</span></div><div class="line">Path path_1 = base.resolve(<span class="string">"BNP.txt"</span>);</div><div class="line"><span class="comment">//output: C:\rafaelnadal\tournaments\2009\BNP.txt</span></div><div class="line">System.out.println(path_1.toString());</div><div class="line"><span class="comment">//resolve AEGON.txt file</span></div><div class="line">Path path_2 = base.resolve(<span class="string">"AEGON.txt"</span>);</div><div class="line"><span class="comment">//output: C:\rafaelnadal\tournaments\2009\AEGON.txt</span></div><div class="line">System.out.println(path_2.toString());</div></pre></td></tr></table></figure></p>
<p><strong>而resolveSibling方法更加好用：可以直接获取相同目录下的其他文件：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//define the fixed path</span></div><div class="line">Path base = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009/BNP.txt"</span>);</div><div class="line"><span class="comment">//resolve sibling AEGON.txt file</span></div><div class="line">Path path = base.resolveSibling(<span class="string">"AEGON.txt"</span>);</div><div class="line"><span class="comment">//output: C:\rafaelnadal\tournaments\2009\AEGON.txt</span></div><div class="line">System.out.println(path.toString());</div></pre></td></tr></table></figure></p>
<p><strong>取得相对路径：</strong><br>假设BNP.txt和AEGON.txt在同一目录下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Path path01 = Paths.get(<span class="string">"BNP.txt"</span>);</div><div class="line">Path path02 = Paths.get(<span class="string">"AEGON.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">//output: ..\AEGON.txt</span></div><div class="line">Path path01_to_path02 = path01.relativize(path02);</div><div class="line">System.out.println(path01_to_path02);</div><div class="line"><span class="comment">//output: ..\BNP.txt</span></div><div class="line">Path path02_to_path01 = path02.relativize(path01);</div><div class="line">System.out.println(path02_to_path01);</div></pre></td></tr></table></figure></p>
<p>假设：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Path path01 = Paths.get(<span class="string">"/tournaments/2009/BNP.txt"</span>);</div><div class="line">Path path02 = Paths.get(<span class="string">"/tournaments/2011"</span>);</div></pre></td></tr></table></figure></p>
<p>那么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//output: ..\..\2011</span></div><div class="line">Path path01_to_path02 = path01.relativize(path02);</div><div class="line">System.out.println(path01_to_path02);</div><div class="line"><span class="comment">//output: ..\2009\BNP.txt</span></div><div class="line">Path path02_to_path01 = path02.relativize(path01);</div><div class="line">System.out.println(path02_to_path01);</div></pre></td></tr></table></figure></p>
<p><strong>遍历：</strong><br>Path实现了Iterable<path></path>接口，也就是说我们可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Path path = Paths.get(<span class="string">"C:"</span>, <span class="string">"rafaelnadal/tournaments/2009"</span>, <span class="string">"BNP.txt"</span>);</div><div class="line"><span class="keyword">for</span> (Path name : path) &#123;</div><div class="line">    System.out.println(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>猜猜结果是什么？<br>我一开始以为是吧目录下的文件遍历出来呢。结果是这样的：<br>rafaelnadal<br>tournaments<br>2009<br>BNP.txt<br>说实话，我觉得这个比较坑爹！ </p>
<h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><p>java.nio.file.attribute包下的类提供了获取文件属性的类，针对不同操作系统使用的类不太一样，当然也有所有操作系统通用的属性。 </p>
<p>属性分类有一些几种：<br>BasicFileAttributeView<br>DosFileAttributeView<br>PosixFileAttributeView<br>FileOwnerAttributeView<br>AclFileAttributeView<br>UserDefinedFileAttributeView</p>
<p><strong>获取属性：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">BasicFileAttributes attr = <span class="keyword">null</span>;</div><div class="line">Path path = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009"</span>, <span class="string">"BNP.txt"</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    attr = Files.readAttributes(path, BasicFileAttributes.class);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.err.println(e);</div><div class="line">&#125;</div><div class="line">System.out.println(<span class="string">"File size: "</span> + attr.size());</div><div class="line">System.out.println(<span class="string">"File creation time: "</span> + attr.creationTime());</div><div class="line">System.out.println(<span class="string">"File was last accessed at: "</span> + attr.lastAccessTime());</div><div class="line">System.out.println(<span class="string">"File was last modified at: "</span> + attr.lastModifiedTime());</div><div class="line">System.out.println(<span class="string">"Is directory? "</span> + attr.isDirectory());</div><div class="line">System.out.println(<span class="string">"Is regular file? "</span> + attr.isRegularFile());</div><div class="line">System.out.println(<span class="string">"Is symbolic link? "</span> + attr.isSymbolicLink());</div><div class="line">System.out.println(<span class="string">"Is other? "</span> + attr.isOther());</div></pre></td></tr></table></figure></p>
<p>或 </p>
<p><code>long size = (Long)Files.getAttribute(path, &quot;basic:size&quot;, NOFOLLOW_LINKS);</code></p>
<p><strong>设置属性：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Path path = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009"</span>, <span class="string">"BNP.txt"</span>);</div><div class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</div><div class="line">FileTime fileTime = FileTime.fromMillis(time);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Files.getFileAttributeView(path,</div><div class="line">        BasicFileAttributeView.class).setTimes(fileTime, fileTime, fileTime);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.err.println(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</div><div class="line">FileTime fileTime = FileTime.fromMillis(time);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Files.setLastModifiedTime(path, fileTime);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.err.println(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>Symbolic和Hard Links</strong><br>相同于用Java程序实现linux下的 ln命令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Path link = FileSystems.getDefault().getPath(<span class="string">"rafael.nadal.1"</span>);</div><div class="line">Path target= FileSystems.getDefault().getPath(<span class="string">"C:/rafaelnadal/photos"</span>, <span class="string">"rafa_winner.jpg"</span>);</div><div class="line">Files.createSymbolicLink(link, target);</div></pre></td></tr></table></figure></p>
<h1 id="DirectoryStream"><a href="#DirectoryStream" class="headerlink" title="DirectoryStream"></a>DirectoryStream</h1><p>这也是一个比较有用的类：用来遍历路径下的子路径或文件，而且支持通配符过滤。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Path path = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009"</span>);</div><div class="line">…</div><div class="line"><span class="comment">//glob pattern applied</span></div><div class="line">System.out.println(<span class="string">"\nGlob pattern applied:"</span>);</div><div class="line"><span class="keyword">try</span> (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(path, <span class="string">"*.&#123;png,jpg,bmp&#125;"</span>)) &#123;</div><div class="line">    <span class="keyword">for</span> (Path file : ds) &#123;</div><div class="line">        System.out.println(file.getFileName());</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.err.println(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="FileVisitor和Files-walkFileTree"><a href="#FileVisitor和Files-walkFileTree" class="headerlink" title="FileVisitor和Files.walkFileTree"></a>FileVisitor和Files.walkFileTree</h1><p>FileVisitor是一个接口，Files.walkFileTree是一个方法。 通过两者的配合可以遍历整个某个路径下的所有子路径和文件。没有这个之前我们用递归方法也能实现，有了这个不能说是现实更加容易， 只能说是现实更加规范， 如果大家都用这个，代码的可维护性会更好。我觉得仅此而已。 </p>
<p>FileVisitor有四个方法 </p>
<ul>
<li><code>FileVisitResult postVisitDirectory(T dir, IOException exc)</code><br>Invoked for a directory after entries in the directory, and all of their descendants, have been visited.  </li>
<li><code>FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)</code><br>  Invoked for a directory before entries in the directory are visited.<br>+<code>FileVisitResult visitFile(T file, BasicFileAttributes attrs)</code><br>  Invoked for a file in a directory.</li>
<li><code>FileVisitResult visitFileFailed(T file, IOException exc)</code><br>  Invoked for a file that could not be visited.</li>
</ul>
<p>FileVisitResult枚举类型：<br>CONTINUE，SKIP_SIBLINGS，SKIP_SUBTREE，TERMINATE</p>
<h1 id="Watch-Service-API"><a href="#Watch-Service-API" class="headerlink" title="Watch Service API"></a>Watch Service API</h1><p>这是NIO2里比较重要的一个新增功能， 以前直接用java监视文件系统的变化是不可能的，只能通过jni的方式调用操作系统的api来对文件系统进行监视。在java7里这部分被加到了标准库里，这样我们就不能在去寻找jni的结果方案了。但是事实上为了保持java的扩平台特性，<strong><em>监控的功能范围被定为各个操作系统的交集，所以没有特殊的情况还是需要直接调用操作系统的api来实现</em></strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watchRNDir</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">try</span> (WatchService watchService = FileSystems.getDefault().newWatchService()) &#123;</div><div class="line">        path.register(watchService, StandardWatchEventKinds.ENTRY_CREATE,</div><div class="line">        StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);</div><div class="line"></div><div class="line">        <span class="comment">//start an infinite loop</span></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="comment">//retrieve and remove the next watch key</span></div><div class="line">            <span class="keyword">final</span> WatchKey key = watchService.take();</div><div class="line">            <span class="comment">//get list of pending events for the watch key</span></div><div class="line">            <span class="keyword">for</span> (WatchEvent&lt;?&gt; watchEvent : key.pollEvents()) &#123;</div><div class="line">                <span class="comment">//get the kind of event (create, modify, delete)</span></div><div class="line">                <span class="keyword">final</span> Kind&lt;?&gt; kind = watchEvent.kind();</div><div class="line">                <span class="comment">//handle OVERFLOW event</span></div><div class="line">                <span class="keyword">if</span> (kind == StandardWatchEventKinds.OVERFLOW) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//get the filename for the event</span></div><div class="line">                <span class="keyword">final</span> WatchEvent&lt;Path&gt; watchEventPath = (WatchEvent&lt;Path&gt;) watchEvent;</div><div class="line">                <span class="keyword">final</span> Path filename = watchEventPath.context();</div><div class="line">                <span class="comment">//print it out</span></div><div class="line">                System.out.println(kind + <span class="string">" -&gt; "</span> + filename);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//reset the key</span></div><div class="line">            <span class="keyword">boolean</span> valid = key.reset();</div><div class="line">            <span class="comment">//exit loop if the key is not valid (if the directory was deleted, for example)</span></div><div class="line">            <span class="keyword">if</span> (!valid) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Random-Access-Files"><a href="#Random-Access-Files" class="headerlink" title="Random Access Files"></a>Random Access Files</h1><p>主要是提供了一个SeekableByteChannel接口，配合ByteBuffer使随机访问文件更加方便。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Path path = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009"</span>, <span class="string">"MovistarOpen.txt"</span>);</div><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1</span>);</div><div class="line">String encoding = System.getProperty(<span class="string">"file.encoding"</span>);</div><div class="line"><span class="keyword">try</span> (SeekableByteChannel seekableByteChannel = (Files.newByteChannel(path, EnumSet.of(StandardOpenOption.READ)))) &#123;</div><div class="line">    <span class="comment">//the initial position should be 0 anyway</span></div><div class="line">    seekableByteChannel.position(<span class="number">0</span>);</div><div class="line">    System.out.println(<span class="string">"Reading one character from position: "</span> + seekableByteChannel.position());</div><div class="line">    seekableByteChannel.read(buffer);</div><div class="line">    buffer.flip();</div><div class="line">    System.out.print(Charset.forName(encoding).decode(buffer));</div><div class="line">    buffer.rewind();</div><div class="line">    <span class="comment">//get into the middle</span></div><div class="line">    seekableByteChannel.position(seekableByteChannel.size()/<span class="number">2</span>);</div><div class="line">    System.out.println(<span class="string">"\nReading one character from position: "</span> + seekableByteChannel.position());</div><div class="line">    seekableByteChannel.read(buffer);</div><div class="line">    buffer.flip();</div><div class="line">    System.out.print(Charset.forName(encoding).decode(buffer));</div><div class="line">    buffer.rewind();</div><div class="line">    <span class="comment">//get to the end</span></div><div class="line">    seekableByteChannel.position(seekableByteChannel.size()-<span class="number">1</span>);</div><div class="line">    System.out.println(<span class="string">"\nReading one character from position: "</span> + seekableByteChannel.position());</div><div class="line">    seekableByteChannel.read(buffer);</div><div class="line">    buffer.flip();</div><div class="line">    System.out.print(Charset.forName(encoding).decode(buffer));</div><div class="line">    buffer.clear();</div><div class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">    System.err.println(ex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Asynchronous-Channel-API"><a href="#Asynchronous-Channel-API" class="headerlink" title="Asynchronous Channel API"></a>Asynchronous Channel API</h1><p>这个是NIO2的较大的变化，有原来的Selecor方法变成方法回调模式。使用上更加方便。并且文件的读写也可以异步的方式实现了。 </p>
<p><strong>异步读取文件 ：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</div><div class="line">Path path = Paths.get(<span class="string">"C:/rafaelnadal/grandslam/RolandGarros"</span>, <span class="string">"story.txt"</span>);</div><div class="line"><span class="keyword">try</span> (AsynchronousFileChannel asynchronousFileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ)) &#123;</div><div class="line">    current = Thread.currentThread();</div><div class="line">    asynchronousFileChannel.read(buffer, <span class="number">0</span>, <span class="string">"Read operation status ..."</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</div><div class="line">            System.out.println(attachment);</div><div class="line">            System.out.print(<span class="string">"Read bytes: "</span> + result);</div><div class="line">            current.interrupt();</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</div><div class="line">            System.out.println(attachment);</div><div class="line">            System.out.println(<span class="string">"Error:"</span> + exc);</div><div class="line">            current.interrupt();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    System.out.println(<span class="string">"\nWaiting for reading operation to end ...\n"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        current.join();</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//now the buffer contains the read bytes</span></div><div class="line">    System.out.println(<span class="string">"\n\nClose everything and leave! Bye, bye ..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">    System.err.println(ex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>异步socket服务器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEchoServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverChannel;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(String.format(<span class="string">"start: name: %s"</span>, Thread.currentThread().getName()));</div><div class="line">        serverChannel = AsynchronousServerSocketChannel.open();</div><div class="line">        serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR, <span class="keyword">true</span>);</div><div class="line">        serverChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>));</div><div class="line">        serverChannel.accept(serverChannel, <span class="keyword">new</span> Acceptor());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>, <span class="title">AsynchronousServerSocketChannel</span>&gt; </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Acceptor</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(<span class="string">"an acceptor has created."</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel channel, AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</div><div class="line">            System.out.println(String.format(<span class="string">"write: name: %s"</span>, Thread.currentThread().getName()));</div><div class="line">            channel.read(buffer, channel, <span class="keyword">new</span> Reader(buffer));</div><div class="line">            serverChannel.accept(serverChannel, <span class="keyword">new</span> Acceptor());</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exception, AsynchronousServerSocketChannel serverChannel)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(exception);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">AsynchronousSocketChannel</span>&gt; </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">private</span> ByteBuffer buffer;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(ByteBuffer buffer)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.buffer = buffer;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, AsynchronousSocketChannel channel)</span></span>&#123;</div><div class="line">            System.out.println(String.format(<span class="string">"read: name: %s"</span>, Thread.currentThread().getName()));</div><div class="line">            <span class="keyword">if</span>(result != <span class="keyword">null</span> &amp;&amp; result &lt; <span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">try</span>&#123;</div><div class="line">                  channel.close();</div><div class="line">                  <span class="keyword">return</span>;</div><div class="line">                &#125;<span class="keyword">catch</span>(IOException ignore)&#123;&#125;</div><div class="line">            &#125;</div><div class="line">            buffer.flip();</div><div class="line">            channel.write(buffer, channel, <span class="keyword">new</span> Writer(buffer));</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exception, AsynchronousSocketChannel channel)</span></span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(exception);</div><div class="line">        &#125;                    </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">AsynchronousSocketChannel</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">        <span class="keyword">private</span> ByteBuffer buffer;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(ByteBuffer buffer)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.buffer = buffer;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, AsynchronousSocketChannel channel)</span> </span>&#123;</div><div class="line">            System.out.println(String.format(<span class="string">"write: name: %s"</span>, Thread.currentThread().getName()));</div><div class="line">            buffer.clear();</div><div class="line">            channel.read(buffer, channel, <span class="keyword">new</span> Reader(buffer));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exception, AsynchronousSocketChannel channel)</span> </span>&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(exception);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>&#123;</div><div class="line">        <span class="keyword">new</span> AsyncEchoServer().start();</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            Thread.sleep(<span class="number">1000L</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.tuicool.com/articles/IRfIJ3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;转自&lt;/a&gt;&lt;br&gt; &lt;img src=&quot;http://oqxil93b6.bkt.clouddn.com/ima
    
    </summary>
    
      <category term="technology" scheme="http://YDDMAX.github.io/categories/technology/"/>
    
    
      <category term="NIO2.0" scheme="http://YDDMAX.github.io/tags/NIO2-0/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://YDDMAX.github.io/2017/06/03/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://YDDMAX.github.io/2017/06/03/负载均衡/</id>
    <published>2017-06-03T13:15:10.000Z</published>
    <updated>2017-06-03T13:21:43.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><blockquote>
<p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p>
</blockquote>
<p>下图展示百度有三个IP地址：<br><img src="http://oqxil93b6.bkt.clouddn.com/images/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/baidu-dns.png" alt="百度DNS"></p>
<ul>
<li><strong>优点:</strong></li>
</ul>
<ol>
<li>可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</li>
<li>动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</li>
</ol>
<ul>
<li><strong>缺点:</strong></li>
</ul>
<ol>
<li>没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</li>
<li>策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</li>
<li>如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</li>
<li>DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</li>
<li>基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</li>
</ol>
<h1 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h1><blockquote>
<p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p>
</blockquote>
<ol>
<li>吞吐率限制<br>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。</li>
<li>重定向访问深度不同<br>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</li>
</ol>
<p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p>
<h1 id="LVS（四层）"><a href="#LVS（四层）" class="headerlink" title="LVS（四层）"></a>LVS（四层）</h1><p>以下内容参考自<a href="http://www.tuicool.com/articles/vQzmi2" target="_blank" rel="external">LVS</a></p>
<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>通过将请求报文的目标地址和目标端口修改为挑选出的某RS的RIP和PORT实现转发；<br>特点：</p>
<ol>
<li><strong>RIP和DIP必须在同一IP网络,且使用私网地址RS的网关应该指向DIP(保证响应报文必须经由VS)</strong></li>
<li><strong>请求和响应报文都要经由director转发；极高负载的场景中，Director可能会成为系统性能瓶颈</strong></li>
<li>支持端口映射</li>
<li>VS必须为Linux，RS可以是任意的OS</li>
<li><strong>调度器上需要两块网卡,一个配置vip 一个配置dip</strong></li>
</ol>
<p><img src="http://oqxil93b6.bkt.clouddn.com/nat.png" alt="NAT"></p>
<h2 id="FULLNAT"><a href="#FULLNAT" class="headerlink" title="FULLNAT"></a>FULLNAT</h2><p>非标准模型, ipvs默认不支持,ipvsadm也不支持。<br>NAT模式的扩展（阿里云的四层SLB使用的是此方式，因为此种方式下负载均衡器和后端服务器的部署不需要部署在同一网络内）<br>通过同时修改请求报文的源IP地址（cip–&gt;dip）和目标IP地址（vip –&gt; rip）实现转发<br>特点：</p>
<ol>
<li>调度器和后端服务器可以不在同一IP网络中</li>
<li>RS收到的请求报文的源IP为DIP，因此其响应报文将发送给DIP；</li>
<li>请求报文和响应报文都必须经由director；</li>
<li>支持端口映射；</li>
<li>RS可使用任意OS；    </li>
</ol>
<p><img src="http://oqxil93b6.bkt.clouddn.com/fullNAT.png" alt="fullNAT"></p>
<h2 id="DR"><a href="#DR" class="headerlink" title="DR"></a>DR</h2><p>直接路由<br>通过为请求报文重新封装一个MAC首部进行转发,源MAC是DIP所在接口的MAC,目标MAC是挑选出的某RS的RIP所在接口的MAC地址；IP首部不会发生变化（源IP为CIP，目标IP始终为VIP） </p>
<ol>
<li>RS跟Director必须在同一物理网络中；RS的网关必须不能指向DIP</li>
<li><strong>请求报文必须由Director调度，但响应报文必须不能经由Director</strong></li>
<li><strong>不支持端口映射</strong></li>
<li>各RS可以使用大多数的OS；一般是linux</li>
</ol>
<p>情形1: RIP DIP VIP 都在一个网络, 都是公网IP 地址</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/dr-same.png" alt="dr-same"></p>
<p>情形2: VIP 是公网ip地址, RIP,DIP是私有地址, 情况要复制些, RS要通过另一个路由出去</p>
<p><img src="http://oqxil93b6.bkt.clouddn.com/dr-no-same.png" alt="dr-nosame"></p>
<p>注意:<br>一个路由其可以有多个网络接口<br>一个交换机可以承载多个ip网络<br>所以路由器1和路由器2可以使用同一个<br>私网交换机和公网交换机也可以用同一个</p>
<h2 id="TUN"><a href="#TUN" class="headerlink" title="TUN"></a>TUN</h2><p>ip tunnel，ip隧道<br>转发方式：不修改请求报文的IP首部（源IP为CIP，目标IP为VIP），而是在原有的IP首部之外再次封装一个IP首部（源IP为DIP，目标IP为RIP）</p>
<ol>
<li>RIP，DIP，VIP全得是公网地址</li>
<li>RS的网关不能也不可能指向DIP</li>
<li>请求报文经由Director调度，但响应报文将直接发给CIP</li>
<li>不支持端口映射</li>
<li>RS的OS必须支持IP隧道功能；</li>
<li><strong>容易超出MTU,  弊端比较大</strong></li>
</ol>
<p><img src="http://oqxil93b6.bkt.clouddn.com/tunnel.png" alt="tunnel"></p>
<h1 id="反向代理（七层）"><a href="#反向代理（七层）" class="headerlink" title="反向代理（七层）"></a>反向代理（七层）</h1><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。<br>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p>
<ol>
<li>任何对于实际服务器的HTTP请求都必须经过调度器</li>
<li>调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</li>
</ol>
<ul>
<li><strong>优点：</strong></li>
</ul>
<ol>
<li>调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</li>
<li>对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</li>
<li>反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</li>
<li>反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</li>
</ol>
<ul>
<li><strong>缺点：</strong><br>反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1>一般工作在四层。<br>性能较高，但是价格昂贵。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的I
    
    </summary>
    
      <category term="technology" scheme="http://YDDMAX.github.io/categories/technology/"/>
    
    
      <category term="technology" scheme="http://YDDMAX.github.io/tags/technology/"/>
    
      <category term="负载均衡" scheme="http://YDDMAX.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>架构的八荣八耻和20个能力</title>
    <link href="http://YDDMAX.github.io/2017/06/03/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%83%BD%E5%8A%9B/"/>
    <id>http://YDDMAX.github.io/2017/06/03/架构的八荣八耻和20个能力/</id>
    <published>2017-06-03T12:27:20.000Z</published>
    <updated>2017-06-03T13:22:55.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqxil93b6.bkt.clouddn.com/images/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%83%BD%E5%8A%9B/barongbachi.png" alt="架构的八荣八耻"></p>
<hr>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%83%BD%E5%8A%9B/architecture-ability.png" alt="此处输入图片的描述"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oqxil93b6.bkt.clouddn.com/images/%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB%E5%92%8C20%E4%B8%AA%E8%
    
    </summary>
    
      <category term="technology" scheme="http://YDDMAX.github.io/categories/technology/"/>
    
    
      <category term="architecture" scheme="http://YDDMAX.github.io/tags/architecture/"/>
    
  </entry>
  
  <entry>
    <title>聚石塔</title>
    <link href="http://YDDMAX.github.io/2017/06/03/%E8%81%9A%E7%9F%B3%E5%A1%94/"/>
    <id>http://YDDMAX.github.io/2017/06/03/聚石塔/</id>
    <published>2017-06-03T11:32:45.000Z</published>
    <updated>2017-06-03T12:24:19.652Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yq.aliyun.com/articles/60879" target="_blank" rel="external">遵循互联网架构“八荣八耻”，解析EWS高质量架构6个维度的20个能力</a>，本文简单介绍了聚石塔和EWS。</p>
<hr>
<blockquote>
<p><strong>聚石塔</strong>是阿里为卖家系统提供的云计算环境，该云环境在全球提供了相应的负载均衡、安全、计算、存储等解决方案。卖家利用聚石塔的基础设施和服务可以快速搭建一套性能优越、扩容简单、资源弹性伸缩、容灾强、支持多活的系统，聚石塔的功能是赋能商家。<br><strong>EWS(Enterprise Workstation)</strong>，是聚石塔中的企业工作站，下图是EWS的系统总架构图。</p>
</blockquote>
<p><img src="http://oqxil93b6.bkt.clouddn.com/images/%E8%81%9A%E7%9F%B3%E5%A1%94/EWS-architecture.png" alt="聚石塔系统架构图"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/60879&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;遵循互联网架构“八荣八耻”，解析EWS高质量架构6个维度的20个能力&lt;/a&gt;，本文简单介绍了聚石塔和EWS。&lt;/p&gt;

    
    </summary>
    
      <category term="ali" scheme="http://YDDMAX.github.io/categories/ali/"/>
    
    
      <category term="technology" scheme="http://YDDMAX.github.io/tags/technology/"/>
    
      <category term="architecture" scheme="http://YDDMAX.github.io/tags/architecture/"/>
    
  </entry>
  
</feed>
